classdef DeepTracker < LabelTracker
  
  properties
    sPrm % new-style DT params
    
    %% train
    
    % - The trained model lives in the fileSys in <cacheDir>/<proj>view%d/trnName.
    % - Right now you can only have one train running at a time.
    
    trnName % char, currently autogenerated. When you retrain, you make a new trnName, every time.
    
    bgTrnMonitorClient % BGClient obj
    bgTrnMonitorWorkerObj; % scalar "detached" object that is deep-copied onto 
      % workers. Note, this is not the BGWorker obj itself
    bgTrnMonitorResultsMonitor % object with resultsreceived() method 
    
    %% track

    % - Right now you can only have one track running at a time.
    
    bgTrkMonitorClient
    bgTrkMonitorWorkerObj
    %bgTrkMonitorResultsMonitor    
    
  end
  properties (Dependent)
    bgTrnReady % If true, asyncPrepare() has been called and asyncStartBGWorker() can be called
  end

  properties
    % track res
    % Since DL writes tracking results to trkfiles, we are going to use the
    % filesys as the tracking-result DB.
    
    % TODO: movierm, moviereorder events
    movIdx2trkfile % map from MovieIndex.id#view%d to a trkfile fullpath
    
    trkP   % [npt x 2 x nfrm x ntgt] tracking results for current mov    [NTst trkD] tracked shapes. In ABSOLUTE coords    
    trkPTS % [npt x nfrm x ntgt] timestamp for trkP*
%     trkPMD % [NTst <ncols>] table. cols: .mov, .frm, .iTgt
%            % .mov has class movieIndex           
    % viz
    hXYPrdRed; % [npts] plot handles for 'reduced' tracking results, current frame and target
    hXYPrdRedOther; % [npts] plot handles for 'reduced' tracking results, current frame, non-current-target
    xyVizPlotArgs; % cell array of args for regular tracking viz    
    xyVizPlotArgsNonTarget; % " for non current target viz
  end
  properties (Dependent)
    nPts % number of label points     
    %hasTrained
  end
  
  events
    % Thrown when trkP/trkPMD are mutated (basically)
    newTrackingResults 
  end
  
  methods
    function v = get.nPts(obj)
      v = obj.lObj.nLabelPoints;
    end
    function v = get.bgTrnReady(obj)
      v = ~isempty(obj.bgTrnMonitorClient);
    end
  end
  
  methods
    function obj = DeepTracker(lObj)
      obj@LabelTracker(lObj);
    end    
    function initHook(obj)
      obj.bgReset();
      obj.trackResInit();
      obj.vizInit();
    end
  end
  
  %% Params
  methods
    function setParams(obj,sPrm)
      % XXX: invalidating/clearing state
      obj.sPrm = sPrm;
    end
    function sPrm = getParams(obj)
      sPrm = obj.sPrm;
    end
    function s = getSaveToken(obj)
      % XXX TODO SEE CPRLT
      s = struct();
      s.sPrm = obj.sPrm;
    end
    function loadSaveToken(obj,s)
      % XXX TODO SEE CPRLT

      obj.sPrm = s.sPrm;
    end
  end
  
  
  %% Train
  methods
    
    % Training timeline
    %
    % - Call to retrain. this creates a new jobname every time.
    % - stripped lbl written to cacheDir
    % - bg trn monitor started
    % - training spawned
    % - as log/intermediate results are written, loss viz in plot.
    % - you can start tracking at any time with the latest model by calling
    % track().
    % - TODO you can't forcibly stop training for now.
    % - TODO you can't choose to use a trained model before the last/final
    % one if say it looked less overtrained or better.
    % - trained models will sit on disk; stripped lbl at 
    % <cache>/<trnName>.lbl, and models at <cache>/.../<trnName>

    
    function retrain(obj)
      % Caller: make sure project is saved. make sure proj has a name, eg
      % from projAssign...

      lblObj = obj.lObj;     
      projname = lblObj.projname;
      assert(~isempty(projname));      
      jobID = datestr(now,'yyyymmddTHHMMSS');
      cacheDir = obj.sPrm.CacheDir;

      trnNameNew = fullfile(cacheDir,'...',jobID);
      if isempty(obj.trnName)
        trnNameOld = fullfile(cacheDir,'...',obj.trnName);
        warningNoTrace('New trained model will be created at %s. Previous trained model at %s will not be deleted.',...
          trnNameNew,trnNameOld);
      end
      obj.trnName = jobID;
      
      % Write stripped lblfile to cacheDir
      s = lblObj.trackCreateStrippedLbl();
      dlLblFile = fullfile(cacheDir,[jobID '.lbl']);
      save(dlLblFile,'-mat','-struct','s');
      fprintf('Saved stripped lbl file: %s\n',dlLblFile);

      % start training
      aptintrf = fullfile(obj.posetfroot,'APT_interface.py');
      cmd = sprintf('%s -n %s %s train',aptintrf,obj.jobID,obj.dlLblFile);
      fprintf(1,'Running %s\n',cmd);
            
      % call BG Train Monitor MOVE ME BEFORE TRAIN
      obj.bgPrepareTrainMonitor(dlLblFile,jobID);
      obj.bgStartTrainMonitor();
    end
    
    function bgTrnReset(obj)
      % Clear all async* state
      %
      % See asyncDetachedCopy for the state copied onto the BG worker. The
      % BG worker depends on: .sPrm, preprocessing parameters/H0/etc for
      % .data*, .trnRes*.
      %
      % - Note, when you change eg params, u need to call this. etc etc.
      % Any mutation that alters PP, train/track on the BG worker...
      % - .trnRes* state is set during train/retrain operations. At the
      % start of these operations we do an asyncReset();
      % - trackResInit() is sometimes called when a change in prune 
      % parameters etc is made. In these cases an asyncReset() will follow

      if ~isempty(obj.bgTrnMonitorClient)
        delete(obj.bgTrnMonitorClient);
      end
      obj.bgTrnMonitorClient = [];
      
      if ~isempty(obj.bgTrnMonitorWorkerObj)
        delete(obj.bgTrnMonitorWorkerObj)
      end
      obj.bgTrnMonitorWorkerObj = [];
      
      if ~isempty(obj.bgTrnMonitorResultsMonitor)
        delete(obj.bgTrnMonitorResultsMonitor);
      end
      obj.bgTrnMonitorResultsMonitor = [];
    end
    
    function bgTrnPrepareMonitor(obj,dlLblFile,jobID)
      obj.bgTrnReset();

      objMon = DeepTrackerTrainingMonitor(obj.lObj.nview);
      cbkResult = @obj.bgTrnResultsReceived;
      workerObj = DeepTrackerTrainingWorkerObj(dlLblFile,jobID);
      bgc = BGClient;
      fprintf(1,'Configuring background worker...\n');
      bgc.configure(cbkResult,workerObj,'compute');
      obj.bgTrnMonitorClient = bgc;
      obj.bgTrnMonitorWorkerObj = workerObj;
      obj.bgTrnMonitorResultsMonitor = objMon;
    end
    
    function bgTrnStart(obj)
      assert(obj.bgTrnReady);
      obj.bgTrnMonitorClient.startWorker('workerContinuous',true,...
        'continuousCallInterval',10);
    end
    
    function bgTrnResultsReceived(obj,sRes)
      obj.bgTrnMonitorResultsMonitor.resultsReceived(sRes);
      
      % XXX call bgTrnStop when done. 
    end
    
    function bgTrnStop(obj)
      obj.bgTrnMonitorClient.stopWorker();
    end       
    
  end
  
  %% Track
  
  methods
    
    % Tracking timeline
    % - Call to track. We are talking a single movie right now.
    % - you must have a .trnName. The most recent model in 
    % <cache>/.../trnName will be used
    % - bg track monitor started. this polls the filesys for a specific
    % file. 
    % - spawn track shell call
    % - when tracking is done for a view, movIdx2trkfile is updated.
    % - when tracking is done for all views, we stop the bgMonitor and we
    % are done.
    
    function track(obj,tblMFT,varargin)
      % Apply trained tracker to the specified frames.
      % 
      % tblMFT: MFTable with cols MFTable.FLDSID
      
      % figure out what to track
      tblMFT = MFTable.sortCanonical(tblMFT);
      mIdx = unique(tblMFT.mov);
      assert(isscalar(mIdx),'scalar movie only');
      tMFTConc = obj.lObj.mftTableConcretizeMov(tblMFT);
      
      f0 = tblMFT.frm(1);
      f1 = tblMFT.frm(end);
      if ~isequal((f0:f1)',tblMFT.frm)
        warningNoTrace('Tracking additional frames to form continuous sequence.');
      end
      
      % check tracker
      if isempty(obj.trnName)
        error('Trained tracker doesn''t exist.');
      end
      trnID = obj.trnName;
      cacheDir = obj.sPrm.CacheDir;
      dlLblFile = fullfile(cacheDir,[trnID '.lbl']);
      if exist(dlLblFile,'file')==0
        error('Cannot find training file: %s\n',dlLblFile);
      end
      
      nview = obj.lObj.nview;
      assert(nview==1,'TODO: multiview');
      assert(obj.lObj.hasTrx==false,'TODO: trx');
      movs = tMFTConc.mov;
      assert(size(movs,2)==nview);
      movs = movs(1,:);
      nowstr = datestr(now,'yyyymmddTHHMMSS');
      for ivw=1:nview
        mov = movs{ivw};
        [movP,movF,movE] = myfileparts(mov);
        trkfile = fullfile(movP,[movF '_' nowstr '.trk']);
        outfile = fullfile(movP,[movF '_' nowstr '.log']);
        fprintf('View %d: trkfile will be written to %s\n',ivw,trkfile);
        
        obj.bgTrkPrepareMonitor(mIdx,ivw,mov,trkfile);
        obj.bgTrkStart();
        
        codestr = DeepTracker.trackCodeGenBsubSing(trnID,dlLblFile,mov,trkfile,f0,f1,...
          'outfile',outfile);
        fprintf('Tracking movie: %s (view%d), frames %d->%d\n',mov,ivw,f0,f1);
        fprintf('%s\n',codestr);
        
        system(codestr);
        
        % what happens on err?  
      end      
    end
    
    function bgTrkReset(obj)
      if ~isempty(obj.bgTrkMonitorClient)
        delete(obj.bgTrkMonitorClient);
      end
      obj.bgTrkMonitorClient = [];
      if ~isempty(obj.bgTrkMonitorWorkerObj)
        delete(obj.bgTrkMonitorWorkerObj)
      end
      obj.bgTrkMonitorWorkerObj = [];      
    end
    
    function bgTrkPrepareMonitor(obj,mIdx,iview,movfile,outfile)
      obj.bgTrkReset();

      cbkResult = @obj.bgTrkResultsReceived;
      workerObj = DeepTrackerTrackingWorkerObj(mIdx,iview,movfile,outfile);
      bgc = BGClient;
      fprintf(1,'Configuring tracking background worker...\n');
      bgc.configure(cbkResult,workerObj,'compute');
      obj.bgTrkMonitorClient = bgc;
      obj.bgTrkMonitorWorkerObj = workerObj;
    end
    
    function bgTrkStart(obj)
      obj.bgTrkMonitorClient.startWorker('workerContinuous',true,...
        'continuousCallInterval',10);
    end
    
    function bgTrkResultsReceived(obj,sRes)
      res = sRes.result;
      if res.tfcomplete
        fprintf(1,'Tracking output file %s detected.\n',res.trkfile);
        obj.bgTrkStop();
        movsFull = obj.lObj.getMovieFilesAllFullMovIdx(res.mIdx);
        mov = movsFull{res.iview};
        if strcmp(mov,res.movfile)
          obj.trackResNewTrkfile(res.mIdx,res.trkfile);
          if res.mIdx==obj.lObj.currMovIdx
            trk = load(res.trkfile,'-mat');
            obj.trackCurrResLoadFromTrk(trk);
            obj.newLabelerFrame();
            notify(obj,'newTrackingResults');
          end          
        else
          warningNoTrace('Tracking complete, but movieset %d, view%d, mov %s does not match current project.',...
            int32(res.mIdx),res.iview,res.movfile);
          % conservative, take no action for now
        end
      end
    end
    
    function bgTrkStop(obj)
      obj.bgTrkMonitorClient.stopWorker();
    end       
    
  end
  methods (Static) % codegen
    function codestr = trackCodeGenBase(trnID,dllbl,movtrk,outtrk,frm0,frm1)
      aptintrf = fullfile(APT.getpathdl,'APT_interface.py');     
      codestr = sprintf('python %s -name %s %s track -mov %s -out %s -start_frame %d -end_frame %d',...
        aptintrf,trnID,dllbl,movtrk,outtrk,frm0,frm1);
    end
    function codestr = trackCodeGenVenv(trnID,dllbl,movtrk,outtrk,frm0,frm1,varargin)
      % TODO: views
      venv = myparse(varargin,...
        'venv','/groups/branson/bransonlab/mayank/venv');
      codestr = sprintf('cd %s; source bin/activate; %s',...
        venv,DeepTracker.trackCodeGenBase(trnID,dllbl,movtrk,outtrk,frm0,frm1));
    end
    function codestr = trackCodeGenSing(trnID,dllbl,movtrk,outtrk,frm0,frm1,varargin)
      DFLTBINDPATH = {
        '/groups/branson/bransonlab'
        '/groups/branson/home'
        '/nrs/branson'
        '/scratch'};      
      [bindpath,singimg] = myparse(varargin,...
        'bindpath',DFLTBINDPATH,...
        'singimg','/misc/local/singularity/branson_v2.simg');
      
      Bflags = [repmat({'-B'},1,numel(bindpath)); bindpath(:)'];
      Bflagsstr = sprintf('%s ',Bflags{:});
      basecmd = DeepTracker.trackCodeGenBase(trnID,dllbl,movtrk,outtrk,frm0,frm1);
      codestr = sprintf('singularity exec --nv %s %s bash -c ". /opt/venv/bin/activate && %s"',...
        Bflagsstr,singimg,basecmd);
    end
    function codestr = trackCodeGenBsubSing(trnID,dllbl,movtrk,outtrk,frm0,frm1,varargin)
      % TODO: views, trx
      [nslots,gpuqueue,outfile,singargs] = myparse(varargin,...
        'nslots',1,...
        'gpuqueue','gpu_any',...
        'outfile','/dev/null',...
        'singargs',{});
      codestrsing = DeepTracker.trackCodeGenSing(trnID,dllbl,movtrk,outtrk,frm0,frm1,singargs{:});
      codestr = sprintf('bsub -n %d -gpu "num=1" -q %s -o %s %s',...
        nslots,gpuqueue,outfile,codestrsing);
    end
    
    
  end
  methods
    
%       switch sRes.action
%         case 'track'
%           obj.updateTrackRes(res.trkPMDnew,res.pTstTRed,res.pTstT);
%           obj.vizLoadXYPrdCurrMovieTarget();
%           obj.newLabelerFrame();
%           notify(obj,'newTrackingResults');
%         case BGWorker.STATACTION
%           computeTimes = res;
%           CPRLabelTracker.asyncComputeStatsStc(computeTimes);
    
    function trackResInit(obj)
      m = containers.Map('keytype','int32','valuetype','any');
      obj.movIdx2trkfile = m;
    end
    function trackResNewTrkfile(obj,mIdx,trkfile)
      m = obj.movIdx2trkfile;
      assert(isscalar(mIdx));
      assert(ischar(trkfile));
      %id = sprintf('%d#vw%d',mIdx.id32(),iview);
      id = mIdx.id32();
      m(id) = trkfile;
    end
      
    function trackCurrResInit(obj)
      obj.trkP = [];
      obj.trkPTS = zeros(0,1);
    end
    function trackCurrResLoadFromTrk(obj,trk)
      % trk: scalar struct, TrkFile contents
      lObj = obj.lObj;
      pTrk = nan(obj.nPts,2,lObj.nframes,lObj.nTargets);
      pTrkTS = nan(obj.nPts,lObj.nframes,lObj.nTargets);
      
      if isfield(trk,'pTrkFrm')
        frms = trk.pTrkFrm;
      else
        frms = 1:size(trk.pTrk,3);
        warningNoTrace('.pTrkFrm not present in trkfile, assuming leading frames.');
      end
      
      pTrk(:,:,frms,:) = trk.pTrk;
      pTrkTS(:,frms,:) = trk.pTrkTS;
      obj.trkP = pTrk;
      obj.trkPTS = pTrkTS;
    end
       
    function [trkfiles,tfHasRes] = getTrackingResults(obj,iMovsSgned)
      
      % XXX TODO 
      
      % Get tracking results for movie(set) iMovs.
      % Default implemation returns all NaNs and tfHasRes=false.
      %
      % iMovsSgned: [nMov] vector of movie(set) indices, negative for GT
      %
      % trkfiles: [nMovxnView] vector of TrkFile objects
      % tfHasRes: [nMov] logical. If true, corresponding movie(set) has 
      % tracking nontrivial (nonempty) tracking results
      
      validateattributes(iMovsSgned,{'numeric'},{'vector' 'integer'});
      
      assert(~obj.lObj.isMultiView,'Multiview unsupported.');
      
      nMov = numel(iMovsSgned);
      for i = nMov:-1:1
        iMovS = iMovsSgned(i);
        iMov = abs(iMovS);
        tfGT = iMovS<0;
        lpos = obj.lObj.getlabeledposGTawareArg(tfGT);
        trkpos = nan(size(lpos{iMov}));
        trkfiles(i) = TrkFile(trkpos);
        tfHasRes(i) = false;
      end
    end
    function xy = getPredictionCurrentFrame(obj)
      % xy: [nPtsx2xnTgt], tracking results for all targets in current frm
      
      frm = obj.lObj.currFrame;
      xyPCM = obj.trkP;
      if isempty(xyPCM)
        npts = obj.nPts;
        nTgt = obj.lObj.nTargets;
        xy = nan(npts,2,nTgt);
      else
        % AL20160502: When changing movies, order of updates to 
        % lObj.currMovie and lObj.currFrame is unspecified. currMovie can
        % be updated first, resulting in an OOB currFrame; protect against
        % this.
        frm = min(frm,size(xyPCM,3));
        xy = squeeze(xyPCM(:,:,frm,:)); % [npt x d x ntgt]
      end
    end
    
    function vizInit(obj)
      deleteValidHandles(obj.hXYPrdRed);
      obj.hXYPrdRed = [];
      deleteValidHandles(obj.hXYPrdRedOther);
      obj.hXYPrdRedOther = [];
      
      % init .xyVizPlotArgs*
      trackPrefs = obj.lObj.projPrefs.Track;
      plotPrefs = trackPrefs.PredictPointsPlot;
      plotPrefs.PickableParts = 'none';
      obj.xyVizPlotArgs = struct2paramscell(plotPrefs);
      obj.xyVizPlotArgsNonTarget = obj.xyVizPlotArgs; % TODO: customize
      
      npts = obj.nPts;
      ptsClrs = obj.lObj.labelPointsPlotInfo.Colors;
      ax = obj.ax;
      %arrayfun(@cla,ax);
      arrayfun(@(x)hold(x,'on'),ax);
      ipt2View = obj.lObj.labeledposIPt2View;
      hTmp = gobjects(npts,1);
      hTmpOther = gobjects(npts,1);
      hTmp2 = gobjects(npts,1);
      for iPt = 1:npts
        clr = ptsClrs(iPt,:);
        iVw = ipt2View(iPt);
        hTmp(iPt) = plot(ax(iVw),nan,nan,obj.xyVizPlotArgs{:},'Color',clr);
        hTmpOther(iPt) = plot(ax(iVw),nan,nan,obj.xyVizPlotArgs{:},'Color',clr);        
        hTmp2(iPt) = scatter(ax(iVw),nan,nan);
        setIgnoreUnknown(hTmp2(iPt),'MarkerFaceColor',clr,...
          'MarkerEdgeColor',clr,'PickableParts','none',...
          obj.xyVizFullPlotArgs{:});
      end
      obj.hXYPrdRed = hTmp;
      obj.hXYPrdRedOther = hTmpOther;
      obj.setHideViz(obj.hideViz);
    end

    function clearTrackingResults(obj)
      % XXX TODO
      %obj.initData();
      obj.trackResInit();
      obj.vizLoadXYPrdCurrMovieTarget();
      obj.newLabelerFrame();
      % Don't asyncReset() here
      notify(obj,'newTrackingResults');
    end
    
    function newLabelerFrame(obj)
      % Update .hXYPrdRed based on current Labeler frame and .xyPrdCurrMovie

      if obj.lObj.isinit || ~obj.lObj.hasMovie
        return;
      end
      
      xy = obj.getPredictionCurrentFrame();
    
%       if obj.asyncPredictOn && all(isnan(xy(:)))
%         obj.asyncTrackCurrFrameBG();
%       end
      
      plotargs = obj.xyVizPlotArgs;
      npts = obj.nPts;
      itgt = obj.lObj.currTarget;
      hXY = obj.hXYPrdRed;
      for iPt=1:npts
        set(hXY(iPt),'XData',xy(iPt,1,itgt),'YData',xy(iPt,2,itgt),plotargs{:});
      end
    end
    function newLabelerTarget(obj)
      obj.newLabelerFrame();
    end
    function newLabelerMovie(obj)
      obj.vizInit();
      if obj.lObj.hasMovie
        obj.newLabelerFrame();
      end
    end
    
    function labelerMovieRemoved(obj,eventdata)
      % XXX TODO
      mIdxOrig2New = eventdata.mIdxOrig2New;
      keys = cell2mat(mIdxOrig2New.keys);
      vals = cell2mat(mIdxOrig2New.values);
      szassert(keys,size(vals));
      mIdx = keys(vals==0);
      mIdx = MovieIndex(mIdx);
      assert(isscalar(mIdx)); % for now
      
%       % .data*. Remove any removed movies from .data cache, relabel MD.mov
%       obj.data.movieRemap(mIdxOrig2New);
%     AL: Now done in Labeler
      
      % trnData*. If a movie is being removed that is in trnDataTblP, to be 
      % safe we invalidate any trained tracker and tracking results.
      tfRm = obj.trnDataTblP.mov==mIdx;
      if any(tfRm)
        if isdeployed
          error('CPRLabelTracker:movieRemoved',...
            'Unexpected codepath for deployed APT.');
        else
          resp = questdlg('A movie present in the training data has been removed. Any trained tracker and tracking results will be cleared.',...
            'Training row removed',...
            'OK','(Dangerous) Do not clear tracker/tracking results','OK');
          if isempty(resp)
            resp = 'OK';
          end
          switch resp
            case 'OK'
              obj.trnDataInit();
              obj.trnResInit();
              obj.trackResInit();
              obj.vizInit();
              obj.asyncReset();
            case '(Dangerous) Do not clear tracker/tracking results'
              obj.trnDataInit();
              % trnRes not cleared
              % trackRes not cleared
            otherwise
              assert(false);
          end
        end
      else
        % .trnDataTblP does not contain a movie-being-removed, but we still
        % need to relabel movie indices.
        obj.trnDataTblP = MFTable.remapIntegerKey(obj.trnDataTblP,'mov',...
          mIdxOrig2New);
        assert(~any(obj.trnDataTblP.mov==0));
      end
      
      % trkP*. Relabel .mov in tables; remove any removed movies from 
      % tracking results. 
      [obj.trkPMD,tfRm] = MFTable.remapIntegerKey(obj.trkPMD,'mov',...
        mIdxOrig2New);
      obj.trkP(tfRm,:) = [];
      if ~isequal(obj.trkPFull,[])
        obj.trkPFull(tfRm,:,:,:) = []; % Should work fine even when .storeFullTracking is .FINALITER and .trkPFull has 3 dims
      end
      obj.trkPTS(tfRm,:) = [];
      
%       obj.vizLoadXYPrdCurrMovieTarget();
%       obj.newLabelerFrame();
    end
    
    function labelerMoviesReordered(obj,eventdata)
      % XXX TODO
            
      mIdxOrig2New = eventdata.mIdxOrig2New;
      vals = cell2mat(mIdxOrig2New.values);
      assert(~any(vals==0),'Unexpected movie removal.');
      
%       obj.data.movieRemap(mIdxOrig2New); AL now done in Labeler
      obj.trnDataTblP = MFTable.remapIntegerKey(obj.trnDataTblP,'mov',...
        mIdxOrig2New);
      obj.trkPMD = MFTable.remapIntegerKey(obj.trkPMD,'mov',mIdxOrig2New);
    end
    
     function props = propList(obj)
       % TODO 
      % Return a list of properties that could be shown in the
      % infotimeline
      props = {'x' 'y' 'dx' 'dy' '|dx|' '|dy|'}';
    end
    
    function data = getPropValues(obj,pcode)

       % TODO 

       % Return the values of a particular property for
      % infotimeline
      
      labeler = obj.lObj;
      npts = labeler.nLabelPoints;
      nfrms = labeler.nframes;
      ntgts = labeler.nTargets;
      iTgt = labeler.currTarget;
      tpos = obj.xyPrdCurrMovie; % "trked pos" ala lpos
      if isempty(tpos)
        % edge case uninitted (not sure why)
        tpos = nan(npts,2,nfrms,ntgts);
      end
      tpostag = cell(npts,nfrms,ntgts);
      data = InfoTimeline.getDataFromLpos(tpos,tpostag,pcode,iTgt);
    end
    

  end  
  
end