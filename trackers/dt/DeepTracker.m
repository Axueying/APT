classdef DeepTracker < LabelTracker
  
  properties (Dependent)
    algorithmName;
    algorithmNamePretty
  end
  properties (Constant,Hidden)
    SAVEPROPS = {'sPrm' 'containerBindPaths' ...
      'trnNetType' 'trnName' 'trnNameLbl' 'trnLastDMC' 'movIdx2trkfile' 'hideViz'}; 
    RemoteAWSCacheDir = '/home/ubuntu';
    jrchost = 'login1.int.janelia.org';
    jrcprefix = 'source /etc/profile';
    jrcprodrepo = '/groups/branson/bransonlab/apt/repo/prod';
    
    pretrained_weights_urls = {...
      'http://download.tensorflow.org/models/official/20181001_resnet/savedmodels/resnet_v2_fp32_savedmodel_NHWC.tar.gz'
      'http://download.tensorflow.org/models/resnet_v1_50_2016_08_28.tar.gz'...
      };
    pretrained_weights_files_pat_lnx = {...
      '%s/pretrained/resnet_v2_fp32_savedmodel_NHWC/1538687283/variables/variables.index'... % fill in deepnetroot
      '%s/pretrained/resnet_v1_50.ckpt'... 
      };
    
  end
  properties
    sPrm % new-style DT params
    
    dryRunOnly % transient, scalar logical. If true, stripped lbl, cmds 
      % are generated for DL, but actual DL train/track are not spawned
  end
%   properties (SetObservable)
%     backendType % scalar DLBackEnd
%   end
  properties
    containerBindPaths % cellstr of bind paths for sing/docker
      % Will be used if it is nonempty; otherwise an attempt will be made 
      % to autogenerate the required bind/mount paths.
      
    %% train
    
    % - The trained model lives in the fileSys in <cacheDir>/<proj>view%d/trnName.
    % - Right now you can only have one train running at a time.
    
    % chars, currently autogenerated.
    % - When you retrain, you make a new trnName, every time.
    % - In the cacheDir, a subfolder is created .../<trnName>. This
    % subfolder holds the entire state for your trained model.
    % - Within the subfolder, multiple stripped lbls may exist:
    %   .../<trnName>/<trnNameLbl1>, .../<trnName>/<trnNameLbl2>, ...
    %   representing restarts-with-data-augmentation. The current stripped
    %   lbl (ie typically the one used in the most recent train) is
    %   identified by .trnNameLbl.
    % - As far as DeepTracker.m is concerned, the only output/artifacts 
    % generated by training are these two identifiers.
    % FUTURE TODO: what happens when user alters cacheDir?
    trnName % modelChainID
    trnNameLbl % trainID
  end
  properties (SetAccess=private)
    trnNetType = DLNetType.mdn; % scalar DLNetType
  end
  properties
    trnLastDMC % [nview] Last DeepModelChainOnDisk(s), set during training
    trnTblP % transient, unmanaged. Training rows for last retrain
    
    bgTrnMonitor % BgTrainMonitor obj
    bgTrnMonBGWorkerObj % bgTrainWorkerObj for last/current train
    bgTrnMonitorVizClass % class of trainMonitorViz object to use to monitor training
        
    %% track

    % - Right now you can only have one track running at a time.
    
    trkGenHeatMaps % transient, scalar logical. If true, include --hmaps opt
      % to generate heatmaps on disk
   
    trkSysInfo % [nview] transient, unmanageed. struct array of info used 
    % for current or most recent tracking codegen/system call. currently 
    % only used for debugging, printing logfiles etc.
    
    bgTrkMonitor % BgTrackMonitor obj
    bgTrkMonBGWorkerObj % bgTrackWorkerObj for last/current rack
    bgTrkMonitorVizClass % class of trackMonitorViz object to use to monitor tracking
    
    % trackres: tracking results DB is in filesys
    movIdx2trkfile % map from MovieIndex.id to [ntrkxnview] cellstrs of trkfile fullpaths
  end
  properties (Dependent)
    bgTrnIsRunning
    bgTrkIsRunning 
  end

  properties
    % track curr res -- in-mem tracking results for current mov    
    trkP   % [npt x 2 x nfrm x ntgt] tracking results for current mov
    trkPTS % [npt x nfrm x ntgt] timestamp for trkP*
%     trkPMD % [NTst <ncols>] table. cols: .mov, .frm, .iTgt
%            % .mov has class movieIndex 
  end
  properties (Dependent)
    nPts % number of label points     
    nview 
    %hasTrained
  end
  
  properties
    trkVizer % scalar TrackingVisualizer
  end
  
  events
    % Thrown when new tracking results are loaded for the current lObj
    % movie
    newTrackingResults 
    
    trainStart
    trainEnd
    trackStart
    trackEnd    
  end
  
  methods
    function v = get.algorithmName(obj)
      v = char(obj.trnNetType);
    end
    function v = get.algorithmNamePretty(obj)
      v = ['Deep Convolutional Network - ' obj.trnNetType.prettyString];
    end
    function v = get.nPts(obj)
      v = obj.lObj.nLabelPoints;
    end
    function v = get.nview(obj)
      v = obj.lObj.nview;
    end
    function v = get.bgTrnIsRunning(obj)
      btm = obj.bgTrnMonitor;
      v = ~isempty(btm) && btm.isRunning;
    end
    function v = get.bgTrkIsRunning(obj)
      btm = obj.bgTrkMonitor;
      v = ~isempty(btm) && btm.isRunning;
    end
  end
  
  methods
    function obj = DeepTracker(lObj,varargin)
      obj@LabelTracker(lObj);
      
      for i=1:2:numel(varargin)
        prop = varargin{i};
        val = varargin{i+1};
        obj.(prop) = val;
      end
      
      obj.bgTrnMonitor = [];
      obj.bgTrnMonitorVizClass = 'TrainMonitorViz';
      obj.bgTrkMonitor = [];
      obj.bgTrkMonitorVizClass = 'TrackMonitorViz';
      
      obj.trkVizer = TrackingVisualizerHeatMap(lObj);
    end
    function delete(obj)
      obj.trnResInit();
      obj.bgTrkReset();
      delete(obj.trkVizer);
      obj.trkVizer = [];
    end
    function initHook(obj)
      obj.trnResInit();
      obj.bgTrkReset();
      obj.trackResInit();
      obj.trackCurrResInit();
      obj.vizInit();
    end
  end
  
  %% Params
  methods
    function setParamContentsSmart(obj,sNew,tfCommonParamsChanged)
      % Set parameter contents (.sPrm), looking at what top-level fields 
      % have changed and clearing obj state appropriately.
      %
      % sNew: scalar struct, parameters
      
      sOld = obj.sPrm;
      obj.sPrm = sNew; % set this now so eg trnResInit() can use
      
%       if isempty(sOld) || isempty(sNew)
%         obj.initHook();
%       else
%       end
        
      tfunchanged = isequaln(sOld,sNew);
      if tfCommonParamsChanged || ~tfunchanged
        obj.initHook();
        fprintf(2,'Parameter change: DeepTracker (%s) cleared.\n',...
          char(obj.trnNetType));
      end
    end
    function sPrm = getParams(obj)
      sPrm = obj.sPrm;
    end
    function tc = getTrackerClassAugmented(obj)
      tc = {class(obj) 'trnNetType' obj.trnNetType};
    end
    function s = getSaveToken(obj)
      s = struct();
      props = obj.SAVEPROPS;
      for p=props(:)',p=p{1}; %#ok<FXSET>
        s.(p) = obj.(p);
      end      
    end
    function loadSaveToken(obj,s)
      s = DeepTracker.modernizeSaveToken(s);
      
      obj.initHook(); % maybe handled upstream
      flds = fieldnames(s);
      flds = setdiff(flds,'hideViz');
      %obj.isInit = true;
%       try
      for f=flds(:)',f=f{1}; %#ok<FXSET>
        obj.(f) = s.(f);
      end
%       catch ME
        %obj.isInit = false;
%         ME.rethrow();
%       end
      %obj.isInit = false;      
      
      obj.dryRunOnly = false;
      
      obj.setHideViz(s.hideViz);
      obj.trackCurrResUpdate();
      obj.newLabelerFrame();
    end
  end
  methods (Static)
    function s = modernizeSaveToken(s)
      % 20181215
      if isfield(s,'awsEc2')
        s = rmfield(s,'awsEc2');
      end
      if isfield(s,'backendType')
        s = rmfield(s,'backendType');
      end
      % 20181218
      if ~isfield(s,'containerBindPaths')
        s.containerBindPaths = cell(0,1);
      end
      % 20181220
      sPrmDflt = APTParameters.defaultParamsStructDT(s.trnNetType);
      sPrm0 = s.sPrm;
      if ~isempty(sPrm0)
        s.sPrm = structoverlay(sPrmDflt,sPrm0,...
          'dontWarnUnrecog',true); % to allow removal of obsolete params
      else
        s.sPrm = sPrmDflt;
      end
    end
  end
  
  %% Backends
  methods
    
%     function setBackend(obj,backEndType)
%       if isa(backEndType,'DLBackEnd')
%         % none
%       else
%         [btbe,btbestrs] = enumeration('DLBackEnd');
%         if ischar(backEndType)          
%           idx = find(strcmpi(backEndType,btbestrs));
%         else 
%           idx = [];
%         end
%         if isempty(idx)
%           error('Unrecognized back end type. Allowed values are: %s',...
%             String.cellstr2CommaSepList(btbestrs));
%         end
%         backEndType = btbe(idx);
%       end
%       obj.backendType = backEndType;
%     end
    
%     function setAWSEC2(obj,aws)
% %       aws = AWSec2(keyName,pem);
% %       aws.instanceID = instanceID;
%       tfsucc = aws.inspectInstance();
%       if ~tfsucc
%         error('Failed to inspect EC2 instanceID %s.',instanceID);
%       end
%       obj.awsEc2 = aws;
%     end
    
  end
  
  %% Train
  methods
    
    function train(obj)
      error('Incremental training is currently unsupported for Deep Learning.');
    end
    
    % Training timeline
    %
    % - Call to retrain. this creates a new jobname every time.
    % - stripped lbl written to <cacheDir>/<trnID>.lbl
    % - bg trn monitor started
    % - training spawned
    % - as log/intermediate results are written, loss viz in plot.
    % - you can start tracking at any time with the latest model by calling
    % track().
    % - FUTURE TODO you can't forcibly stop training for now.
    % - FUTURE TODO you can't choose to use a trained model before the last/final
    % - FUTURE TODO clean up old/unwanted trained models.
    % one if say it looked less overtrained or better.
    % - trained models will sit on disk; stripped lbl at 
    % <cache>/<trnName>.lbl, and models at <cache>/.../<trnName>
    
    % For Training, there are two processes
    % 1. The backend train itself. After this is spawned, this currently 
    % cannot be managed/killed from this class. If there is an issue the
    % actual compute needs to be manually killed.
    % 2. Background monitoring of the train. This can be reset with
    % bgTrnReset().
    
    function trnResInit(obj)
      obj.trnName = '';
      obj.trnNameLbl = '';
      obj.bgTrnReset();
    end

    function bgTrnStart(obj,backEnd,dmcs)
      % fresh start new training monitor 
            
      if ~isempty(obj.bgTrnMonitor)
        error('Training monitor exists. Call .bgTrnReset first to stop/remove existing monitor.');
      end
      assert(isempty(obj.bgTrnMonBGWorkerObj));

      nvw = obj.lObj.nview;
      assert(numel(dmcs)==nvw);

      trnMonObj = BgTrainMonitor;
      addlistener(trnMonObj,'bgStart',@(s,e)obj.notify('trainStart'));
      addlistener(trnMonObj,'bgEnd',@(varargin) obj.trainStoppedCbk(varargin{:}));

      switch backEnd.type
        case DLBackEnd.Bsub
          trnWrkObj = BgTrainWorkerObjBsub(nvw,dmcs);
        case DLBackEnd.Docker
          trnWrkObj = BgTrainWorkerObjDocker(nvw,dmcs);
        case DLBackEnd.AWS
          trnWrkObj = BgTrainWorkerObjAWS(nvw,dmcs,backEnd.awsec2);
        otherwise
          assert(false);
      end

      trnVizObj = feval(obj.bgTrnMonitorVizClass,nvw,obj,trnWrkObj,backEnd.type);
                
      trnMonObj.prepare(trnVizObj,trnWrkObj);
      trnMonObj.start();
      obj.bgTrnMonitor = trnMonObj;
      obj.bgTrnMonBGWorkerObj = trnWrkObj;
    end
    
    function bgTrnRestart(obj,bgTrnMonitorObj)
      % Mostly for debugging hanging monitors. "Kills" current bg training
      % monitor and restarts.
      
      fprintf(2,'Needs cleanup\n');
      
      if isempty(obj.bgTrnMonitor) || isempty(obj.bgTrnMonBGWorkerObj)
        error('Training monitor does not exist.');
      end
      
      workerObj = obj.bgTrnMonBGWorkerObj;
      fprintf(1,'Restarting bg train monitor. Monitor cls: %s. Worker cls: %s\n',...
        class(bgTrnMonitorObj),class(workerObj));

      workerObj.reset();
      delete(obj.bgTrnMonitor);
      obj.bgTrnMonitor = [];
      obj.bgTrnMonBGWorkerObj = [];
      
      obj.bgTrnStart(bgTrnMonitorObj,workerObj); % xxx TODO
    end

    function bgTrnReset(obj)
      % stop the training monitor
      if ~isempty(obj.bgTrnMonitor)
        delete(obj.bgTrnMonitor);
      end
      obj.bgTrnMonitor = [];      
      if ~isempty(obj.bgTrnMonBGWorkerObj)
        delete(obj.bgTrnMonBGWorkerObj);
      end
      obj.bgTrnMonBGWorkerObj = [];
    end    
    
    function tf = getHasTrained(obj)
      tf = ~isempty(obj.trnName);
    end
    
    function [tfCanTrain,reason] = canTrain(obj)
      
      tfCanTrain = false;
      reason = '';
      if obj.bgTrnIsRunning
        reason = 'Training is already in progress.';
        return;
      end
      if obj.bgTrkIsRunning,
        reason = 'Tracking is in progress.';
        return;
      end
      if isempty(obj.sPrm)
        reason = 'No tracking parameters have been set.';
        return;
      end
      cacheDir = obj.lObj.trackDLParams.CacheDir;
      if isempty(cacheDir)
        reason = 'No cache directory has been set.';
        return;
      end
      
      lblObj = obj.lObj;
      projname = lblObj.projname;
      if isempty(projname)
        reason = 'Please give your project a name. The project name will be used to identify your trained models on disk.';
        return;
      end
      
      backend = lblObj.trackDLBackEnd;
      [tf,reasonbackend] = backend.getReadyTrainTrack();
      if ~tf
        reason = reasonbackend;
        return;
      end
      
      if isempty(obj.trnNetType)
        reason = 'Deep net type is empty.';
        return;
      end
      
      tfCanTrain = true;      
    end
    
    function retrain(obj,varargin)
      
      [wbObj,dlTrnType,oldVizObj] = myparse(varargin,...
        'wbObj',[],...
        'dlTrnType',DLTrainType.New, ...
        'oldVizObj',[] ...
        );
      
      if obj.bgTrnIsRunning
        error('Training is already in progress.');
      end
      
      if obj.bgTrkIsRunning
        error('Tracking is in progress.');
      end
      if isempty(obj.sPrm)
        error('No tracking parameters have been set.');
      end
      cacheDir = obj.lObj.trackDLParams.CacheDir;
      if isempty(cacheDir)
        error('No cache directory has been set.');
      end
      
      lblObj = obj.lObj;
      projname = lblObj.projname;
      if isempty(projname)
        error('Please give your project a name. The project name will be used to identify your trained models on disk.');
      end      
      
      trnBackEnd = lblObj.trackDLBackEnd;
      fprintf('Your deep net type is: %s\n',char(obj.trnNetType));
      fprintf('Your training backend is: %s\n',char(trnBackEnd.type));
      fprintf('Your training vizualizer is: %s\n',obj.bgTrnMonitorVizClass);
      fprintf(1,'\n');      
      
      if obj.isTrkFiles(),
        
        res = questdlg('Tracking results exist for previous deep trackers. When training stops, these will be deleted. Continue training?','Continue training?','Yes','No','Cancel','Yes');
        if ~strcmpi(res,'Yes'),
          return;
        end
        
      end
      
      obj.bgTrnReset();
      if ~isempty(oldVizObj),
        delete(oldVizObj);
      end

      
      modelChain0 = obj.trnName;
      switch dlTrnType
        case DLTrainType.New
          modelChain = datestr(now,'yyyymmddTHHMMSS');
          if ~isempty(modelChain0)
            assert(~strcmp(modelChain,modelChain0));
            fprintf('Training new model %s.\n',modelChain);
          end
        case {DLTrainType.Restart DLTrainType.RestartAug}
          if isempty(modelChain0)
            error('Model has not been trained.');
          end
          modelChain = modelChain0;
          fprintf('Restarting train on model %s.\n',modelChain);
        otherwise
          assert(false);
      end
      
      switch trnBackEnd.type
        case {DLBackEnd.Bsub DLBackEnd.Docker}
          obj.trnSpawnBsubDocker(trnBackEnd,dlTrnType,modelChain,'wbObj',wbObj);
        case DLBackEnd.AWS
          obj.trnSpawnAWS(trnBackEnd,dlTrnType,modelChain,'wbObj',wbObj);          
        otherwise
          assert(false);
      end
      
      % Nothing should occur here as failed trnSpawn* will early return      
    end
    
    function trnPrintLogs(obj)
      modelChainID = obj.trnName;
      if isempty(modelChainID) 
        error('Training is not complete or in progress.');
      end
      if ~obj.bgTrnIsRunning
        fprintf('Training is not in progress; log is for most recent training session.\n');
      end
      
      trnBgWorkerObj = obj.bgTrnMonBGWorkerObj;
      trnBgWorkerObj.printLogfiles();      
    end
    
    function trnPrintModelChainDir(obj)
      modelChainID = obj.trnName;
      if isempty(modelChainID) 
        error('Training is not complete or in progress.');
      end
      if ~obj.bgTrnIsRunning
        fprintf('Training is not in progress; log is for most recent training session.\n');
      end
      trnBgWorkerObj = obj.bgTrnMonBGWorkerObj;
      trnBgWorkerObj.dispModelChainDir();
    end
    
    function trnKill(obj)
      if ~obj.bgTrnIsRunning
        error('Training is not in progress.');
      end
      
      obj.bgTrnMonBGWorkerObj.killProcess();      
    end
    
  end
%   methods (Static)
%     function s = trnLogfileStc(cacheDir,trnID,iview)
%       s = fullfile(cacheDir,sprintf('%s_view%d.log',trnID,iview));
%     end
%   end
  methods
    %% BSub Trainer
      
    function trnSpawnBsubDocker(obj,backEnd,trnType,modelChainID,varargin)
      %
      % backEnd: scalar DLBackEndClass
      % trnType: scalar DLTrainType
      % modelChainID: trainID 
      %
      % PostConds (success):
      %  - training aws job spawned
      %  - .trnName, .trnNameLbl, trnLastDMC set
      %
      % TODO break up bsub/docker sep meths

      [wbObj] = myparse(varargin,...
        'wbObj',[]... 
        );
      
      % (aws check instance running)
      
      cacheDir = obj.lObj.trackDLParams.CacheDir;
      
      % Currently, cacheDir must be visible on the JRC shared filesys.
      % In the future, we may need i) "localWSCache" and ii) "jrcCache".
      
      % (aws update remote repo)
      switch backEnd.type
        case DLBackEnd.Bsub
          DeepTracker.cloneJRCRepoIfNec(cacheDir);
          DeepTracker.updateAPTRepoExecJRC(cacheDir);
          DeepTracker.cpupdatePTWfromJRCProdExec(cacheDir);
        case DLBackEnd.Docker
          obj.downloadPretrainedWeights('aptroot',APT.Root); 
      end
            
       % Base DMC, to be further copied/specified per-view
      dmc = DeepModelChainOnDisk(...   
        'rootDir',cacheDir,...
        'projID',obj.lObj.projname,...
        'netType',char(obj.trnNetType),...
        'view',nan,... % to be filled in 
        'modelChainID',modelChainID,...
        'trainID','',... % to be filled in 
        'trainType',trnType,...
        'iterFinal',obj.sPrm.dl_steps);
        %'backEnd',backEnd);
      
      
      % create/ensure stripped lbl; set trainID
      tfGenNewStrippedLbl = trnType==DLTrainType.New || trnType==DLTrainType.RestartAug;
      if tfGenNewStrippedLbl
        s = obj.trnCreateStrippedLbl(backEnd,'wbObj',wbObj); %#ok<NASGU>
        
        trainID = datestr(now,'yyyymmddTHHMMSS');
        dmc.trainID = trainID;
        
        % Write stripped lblfile to local cache
        dlLblFileLcl = dmc.lblStrippedLnx;
        dlLblFileLclDir = fileparts(dlLblFileLcl);
        if exist(dlLblFileLclDir,'dir')==0
          fprintf('Creating dir: %s\n',dlLblFileLclDir);
          [succ,msg] = mkdir(dlLblFileLclDir);
          if ~succ
            error('Failed to create dir %s: %s',dlLblFileLclDir,msg);
          end
        end
        save(dlLblFileLcl,'-mat','-v7.3','-struct','s');
        fprintf('Saved stripped lbl file: %s\n',dlLblFileLcl);
      else % Restart
        trainID = obj.trnNameLbl;
        assert(~isempty(trainID));
        
        dmc.trainID = trainID;

        dlLblFileLcl = dmc.lblStrippedLnx;
        if exist(dlLblFileLcl,'file')>0
          fprintf(1,'Found existing stripped lbl file: %s\n',dlLblFileLcl);
        else
          error('Cannot find stripped lbl file: %s',dlLblFileLcl);
        end
        
        dmc.restartTS = datestr(now,'yyyymmddTHHMMSS');
      end

      % At this point
      % We have (modelChainID,trainID). stripped lbl is on disk. 

      nvw = obj.lObj.nview;
      syscmds = cell(nvw,1);
      switch backEnd.type
        case DLBackEnd.Bsub
          jrcaptroot = [cacheDir '/APT'];
          mntPaths = obj.genContainerMountPath('aptroot',jrcaptroot);
        case DLBackEnd.Docker 
          mntPaths = obj.genContainerMountPath();          
      end
      
      switch backEnd.type
        case DLBackEnd.Bsub
          singArgs = {'bindpath',mntPaths};
          for ivw=1:nvw
            if ivw>1
              dmc(ivw) = dmc(1).copy();
            end
            dmc(ivw).view = ivw-1; % 0-based
            syscmds{ivw} = DeepTracker.trainCodeGenSSHBsubSingDMC(dmc(ivw),...
              'singArgs',singArgs);
          end
        case DLBackEnd.Docker
          containerNames = cell(nvw,1);
          logcmds = cell(nvw,1);
          for ivw=1:nvw
            if ivw>1
              dmc(ivw) = dmc(1).copy();
            end
            dmc(ivw).view = ivw-1; % 0-based
            [syscmds{ivw},containerNames{ivw}] = ...
              DeepTracker.trainCodeGenDockerDMC(dmc(ivw),mntPaths);
            logcmds{ivw} = sprintf('docker logs -f %s &> %s &',...
              containerNames{ivw},dmc(ivw).trainLogLnx);
          end          
        otherwise
          assert(false);
      end
      
      if obj.dryRunOnly
        cellfun(@(x)fprintf(1,'Dry run, not training: %s\n',x),syscmds);
      else
        obj.bgTrnStart(backEnd,dmc);
        
        bgTrnWorkerObj = obj.bgTrnMonBGWorkerObj;
        
        % spawn training
        if backEnd.type==DLBackEnd.Docker
          bgTrnWorkerObj.jobID = cell(nvw,1);
          for iview=1:nvw
            fprintf(1,'%s\n',syscmds{iview});
            [st,res] = system(syscmds{iview});
            if st==0
              containerID = strtrim(res);
              fprintf('Training job (view %d) spawned, docker containerID=%s.\n\n',...
                iview,containerID);
              % assigning to 'local' workerobj, not the one copied to workers
              bgTrnWorkerObj.jobID{iview} = containerID; 
              
              fprintf(1,'%s\n',logcmds{iview});
              [st2,res2] = system(logcmds{iview});
              if st2==0
              else
                fprintf(2,'Failed to spawn logging job for view %d: %s.\n\n',...
                  iview,res2);
              end
            else
              fprintf(2,'Failed to spawn training job for view %d: %s.\n\n',...
                iview,res);
            end            
          end
        else
          bgTrnWorkerObj.jobID = nan(nvw,1);
          for iview=1:nvw
            fprintf(1,'%s\n',syscmds{iview});
            [st,res] = system(syscmds{iview});
            if st==0
              PAT = 'Job <(?<jobid>[0-9]+)>';
              stoks = regexp(res,PAT,'names');
              if ~isempty(stoks)
                jobid = str2double(stoks.jobid);
              else
                jobid = nan;
                warningNoTrace('Failed to ascertain jobID.');
              end
              fprintf('Training job (view %d) spawned, jobid=%d.\n\n',...
                iview,jobid);
              % assigning to 'local' workerobj, not the one copied to workers
              bgTrnWorkerObj.jobID(iview) = jobid;
            else
              fprintf('Failed to spawn training job for view %d: %s.\n\n',...
                iview,res);
            end
          end
        end        
        obj.trnName = modelChainID;
        obj.trnNameLbl = trainID;
        obj.trnLastDMC = dmc;
      end
    end
    
%     function s = trnLogfileBsub(obj,iview)
%       % fullpath to training bsub logfile
%       s = DeepTracker.trnLogfileStc(obj.sPrm.CacheDir,obj.trnName,iview);
%     end
    
    function [tfsucc,hedit] = testBsubConfig(obj,varargin)
      
      tfsucc = false;
      [host] = myparse(varargin,'host',DeepTracker.jrchost);

      hfig = dialog('Name','Test JRC Cluster Backend','Color',[0,0,0],'WindowStyle','normal');
      hedit = uicontrol(hfig,'Style','edit','Units','normalized','Position',[.05,.05,.9,.9],...
        'Enable','inactive','Min',0,'Max',10,'HorizontalAlignment','left',...
        'BackgroundColor',[.1,.1,.1],'ForegroundColor',[0,1,0]);
      hedit.String = {sprintf('%s: Testing JRC cluster backend...',datestr(now))}; drawnow;
      
      % is APTCache set?
      hedit.String{end+1} = ''; drawnow;
      hedit.String{end+1} = '** Testing that Deep Track->CacheDir parameter is set...'; drawnow;
      dlPrmsCommon = obj.lObj.trackDLParams; 
      if ~( isfield(dlPrmsCommon,'CacheDir') && ~isempty(dlPrmsCommon.CacheDir) )            
        hedit.String{end+1} = 'Deep Track->CacheDir tracking parameter is not set. Please go to Track->Configure tracking parameters menu to set this.'; drawnow;
        return;
      end
      % does APTCache exist? 
      cacheDir = dlPrmsCommon.CacheDir;
      if ~exist(cacheDir,'dir'),
        hedit.String{end+1} = sprintf('Deep Track->CacheDir %s did not exist, trying to create it...',cacheDir); drawnow;
        [tfsucc1,msg1] = mkdir(cacheDir);
        if ~tfsucc1 || ~exist(cacheDir,'dir'),
          hedit.String{end+1} = sprintf('Deep Track->CacheDir %s could not be created: %s. Make sure you have access to %s, and/or set CacheDir to a different directory.',cacheDir,msg1,cacheDir); drawnow;
          return;
        end
      end
      hedit.String{end+1} = sprintf('Deep Track->CacheDir set to %s, and exists.',cacheDir); drawnow;
      hedit.String{end+1} = 'SUCCESS!'; drawnow;
      
      % test that you can ping jrc host
      hedit.String{end+1} = ''; drawnow;
      hedit.String{end+1} = sprintf('** Testing that host %s can be reached...\n',host); drawnow;
      cmd = sprintf('ping -c 1 -W 10 %s',host);
      hedit.String{end+1} = cmd; drawnow;
      [status,result] = system(cmd);
      hedit.String{end+1} = result; drawnow;
      if status ~= 0,
        hedit.String{end+1} = 'FAILURE. Error with ping command.'; drawnow;
        return;
      end
      m = regexp(result,' (\d+) received, (\d+)% packet loss','tokens','once');
      if isempty(m),
        hedit.String{end+1} = 'FAILURE. Could not parse ping output.'; drawnow;
        return;
      end
      if str2double(m{1}) == 0,
        hedit.String{end+1} = sprintf('FAILURE. Could not ping %s:\n',host); drawnow;
        return;
      end
      hedit.String{end+1} = 'SUCCESS!'; drawnow;
      
      % test that we can connect to jrc host and access CacheDir on it
     
      hedit.String{end+1} = ''; drawnow;
      hedit.String{end+1} = sprintf('** Testing that we can do passwordless ssh to %s...',host); drawnow;
      touchfile = fullfile(cacheDir,sprintf('testBsub_test_%s.txt',datestr(now,'yyyymmddTHHMMSS.FFF')));
      
      remotecmd = sprintf('touch %s; if [ -e %s ]; then rm -f %s && echo "SUCCESS"; else echo "FAILURE"; fi;',touchfile,touchfile,touchfile);
      cmd1 = DeepTracker.codeGenSSHGeneral(remotecmd,'host',host,'bg',false);
      cmd = sprintf('timeout 20 %s',cmd1);
      hedit.String{end+1} = cmd; drawnow;
      [status,result] = system(cmd);
      hedit.String{end+1} = result; drawnow;
      if status ~= 0,
        hedit.String{end+1} = sprintf('ssh command timed out. This could be because passwordless ssh to %s has not been set up. Please see APT wiki for more details.',host); drawnow;
        return;
      end
      issuccess = contains(result,'SUCCESS');
      isfailure = contains(result,'FAILURE');
      if issuccess && ~isfailure,
        hedit.String{end+1} = 'SUCCESS!'; drawnow;
      elseif ~issuccess && isfailure,
        hedit.String{end+1} = sprintf('FAILURE. Could not create file in CacheDir %s:',cacheDir); drawnow;
        return;
      else
        hedit.String{end+1} = 'FAILURE. ssh test failed.'; drawnow;
        return;
      end
      
      % test that we can run bjobs
      hedit.String{end+1} = '** Testing that we can interact with the cluster...'; drawnow;
      remotecmd = 'bjobs';
      cmd = DeepTracker.codeGenSSHGeneral(remotecmd,'host',host);
      hedit.String{end+1} = cmd; drawnow;
      [status,result] = system(cmd);
      hedit.String{end+1} = result; drawnow;
      if status ~= 0,
        hedit.String{end+1} = sprintf('Error running bjobs on %s',host); drawnow;
        return;
      end
      hedit.String{end+1} = 'SUCCESS!'; 
      hedit.String{end+1} = ''; 
      hedit.String{end+1} = 'All tests passed. JRC Backend should work for you.'; drawnow;
      
      tfsucc = true;
      
    end

    function paths = genContainerMountPath(obj,varargin)
      
      aptroot = myparse(varargin,...
        'aptroot',APT.Root);
      
      if ~isempty(obj.containerBindPaths)
        assert(iscellstr(obj.containerBindPaths),'containerBindPaths must be a cellstr.');
        fprintf('Using user-specified container bind-paths:\n');
        paths = obj.containerBindPaths;
      else
        lObj = obj.lObj;
        
        macroCell = struct2cell(lObj.projMacrosGetWithAuto());
        cacheDir = obj.lObj.trackDLParams.CacheDir;
        assert(~isempty(cacheDir));
        
        mfaf = lObj.movieFilesAllFull;
        tfaf = lObj.trxFilesAllFull;
        mfafgt = lObj.movieFilesAllGTFull;
        tfafgt = lObj.trxFilesAllGTFull;
        
        projbps = cell(0,1);
        projbps = DeepTracker.hlpAugBasePathsWithWarn(projbps,mfaf,'.movieFilesAllFull');
        if ~isempty(mfafgt)
          projbps = DeepTracker.hlpAugBasePathsWithWarn(projbps,mfafgt,'.movieFilesAllGTFull');
        end
        if lObj.hasTrx
          projbps = DeepTracker.hlpAugBasePathsWithWarn(projbps,tfaf,'.trxFilesAllFull');
          if ~isempty(tfafgt)
            projbps = DeepTracker.hlpAugBasePathsWithWarn(projbps,tfafgt,'.trxFilesAllGTFull');
          end
        end
        
%         % add in home directory and their ancestors
%         homedir = getuserdir;
%         homeancestors = [{homedir},getpathancestors(homedir)];
%         if isunix,
%           homeancestors = setdiff(homeancestors,{'/'});
%         end
        
        fprintf('Using auto-generated container bind-paths:\n');
        dlroot = [aptroot '/deepnet'];
        paths = [cacheDir;dlroot;macroCell(:);projbps(:)];
        paths = unique(paths);
      end
      
      cellfun(@(x)fprintf('  %s\n',x),paths);
    end   
    
    function updateLastDMCsCurrInfo(obj)
      % call .updateCurrInfo on .trnLastDMCs with current backend
      
      be = obj.lObj.trackDLBackEnd;
      switch be.type
        case DLBackEnd.AWS
          aws = be.awsec2;
          args = {'getMostRecentModelMeth' 'getMostRecentModelAWS' ...
                  'getMostRecentModelMethArgs' {aws}};
        otherwise
          % Assume locally-accessible cache. Win may cause a beef
          args = {};
      end
      
      dmcs = obj.trnLastDMC;
      for i=1:numel(dmcs)
        dmcs(i).updateCurrInfo(args{:});
      end
    end
    
  end
  methods (Static)
    function basepaths = hlpAugBasePathsWithWarn(basepaths,newpaths,descstr)
      bps = FSPath.commonbase(newpaths);
      if isempty(bps)
        % no nonempty common base found, ie common base is '/'
        warningNoTrace('No common base path found for %s.',descstr);
      else
        fprintf(1,'Found base path ''%s'' for %s.\n',bps,descstr);
        basepaths{end+1,1} = bps;
      end
    end    
  end
  %% AWS Trainer    
  methods
      
    function trnSpawnAWS(obj,backend,trnType,modelChainID,varargin)
      %
      % backend: scalar DLBackEndClass
      % trnType: scalar DLTrainType
      % modelChainID: trainID 
      %
      % PostConds (success):
      %  - training aws job spawned
      %  - .trnName, .trnNameLbl, trnLastDMC set
      
      [wbObj] = myparse(varargin,...
        'wbObj',[]... 
        );
            
      nvw = obj.lObj.nview;
      
      aws = backend.awsec2;
%       if numel(aws)~=nvw
%         error('You must have one AWSec2 object for each view.');
%       end
      assert(nvw==1,'Multiview AWS train currently unsupported.');
      if isempty(aws)
        error('AWSec2 object not set.');
      end
      aws.checkInstanceRunning(); % harderrs if instance isn't running
%       fprintf('AWS EC2 instance id %s is running...\n\n',aws.instanceID);

      DeepTracker.updateAPTRepoExecAWS(aws);
      
      % Base DMC, to be further copied/specified per-view
      dmc = DeepModelChainOnDisk(...        
        'rootDir',obj.RemoteAWSCacheDir,...
        'projID',obj.lObj.projname,...
        'netType',char(obj.trnNetType),...
        'view',nan,... % to be filled in 
        'modelChainID',modelChainID,...
        'trainID','',... % to be filled in 
        'trainType',trnType,...
        'iterFinal',obj.sPrm.dl_steps);
      dmcLcl = dmc.copy();
      dmcLcl.rootDir = obj.lObj.trackDLParams.CacheDir;      
      
      % create/ensure stripped lbl, local and remote
      tfGenNewStrippedLbl = trnType==DLTrainType.New || trnType==DLTrainType.RestartAug;
      if tfGenNewStrippedLbl        
        s = obj.trnCreateStrippedLbl(backend,'awsTrxUpload',true,'wbObj',wbObj); %#ok<NASGU>
        
        trainID = datestr(now,'yyyymmddTHHMMSS');
        dmc.trainID = trainID;
        dmcLcl.trainID = trainID;
        
        % Write stripped lblfile to local cache
        dlLblFileLcl = dmcLcl.lblStrippedLnx;
        dlLblFileLclDir = fileparts(dlLblFileLcl);
        
        % MK 2019018. Creating the cache dir in case it does not exist
        % realized later that cache dir should exist by default.
        % so commenting it out for now, but might be useful.
%         dlCacheDir = fileparts(dlLblFileLclDir);
%         if exist(dlCacheDir,'dir')==0
%           fprintf('Creating local dir: %s\n',dlCacheDir);
%           [succ,msg] = mkdir(dlCacheDir);
%           if ~succ
%             error('Failed to create local dir %s: %s',dlCacheDir,msg);
%           end
%         end
        
        if exist(dlLblFileLclDir,'dir')==0
          fprintf('Creating local dir: %s\n',dlLblFileLclDir);
          [succ,msg] = mkdir(dlLblFileLclDir);
          if ~succ
            error('Failed to create local dir %s: %s',dlLblFileLclDir,msg);
          end
        end
        save(dlLblFileLcl,'-mat','-v7.3','-struct','s');
        fprintf('Saved stripped lbl file locally: %s\n',dlLblFileLcl);
      else % Restart
        trainID = obj.trnNameLbl;
        assert(~isempty(trainID));
        
        dmc.trainID = trainID;
        dmcLcl.trainID = trainID;

        dlLblFileLcl = dmcLcl.lblStrippedLnx;
        if exist(dlLblFileLcl,'file')>0
          fprintf(1,'Found existing local stripped lbl file: %s\n',dlLblFileLcl);
        else
          error('Cannot find local stripped lbl file: %s',dlLblFileLcl);
        end
        
        dmc.restartTS = datestr(now,'yyyymmddTHHMMSS');
        dmcLcl.restartTS = dmc.restartTS;        
      end
      dlLblFileRemote = dmc.lblStrippedLnx;
      aws.scpUploadOrVerifyEnsureDir(dlLblFileLcl,dlLblFileRemote,'training file');
      
      % At this point
      % We have (modelChainID,trainID), dlLblFileRemote. remote is ready to 
      % train

      % gen cmd to fire job
      syscmds = cell(nvw,1);
      for ivw=1:nvw
        if ivw>1
          dmc(ivw) = dmc(1).copy();
        end
        dmc(ivw).view = ivw-1; % 0-based
        
        codestr = obj.trainCodeGenAWS(dmc(ivw));
        logfileRemote = dmc(ivw).trainLogLnx;
        syscmds{ivw} = aws.sshCmdGeneralLogged(codestr,logfileRemote);
      end
            
      if obj.dryRunOnly
        cellfun(@(x)fprintf(1,'Dry run, not training: %s\n',x),syscmds);
      else
        obj.bgTrnStart(backend,dmc);

        % spawn training
        for iview=1:nvw
          if iview>1
            fprintf(2,'Skipping spawn view %d\n',iview);
            continue;
          end
          fprintf(1,'%s\n',syscmds{iview});
          system(syscmds{iview});
          fprintf('Training job (view %d) spawned.\n\n',iview);
          
          pause(1.0); % Hack try to more reliably get PID
          aws.getRemotePythonPID(); % Conceptually, bgTrnWorkerObj should
            % remember. Right now there is only one PID per aws so it's ok
        end
        
        obj.trnName = modelChainID;
        obj.trnNameLbl = trainID;
        obj.trnLastDMC = dmc;
      end
    end
        
    function s = trnCreateStrippedLbl(obj,backEnd,varargin)
      % - Mutates .trnTblP
      % - Uploads trxs via AWS (maybe factor this out later)
      % - Can throw
      
      [awsTrxUpload,wbObj] = myparse(varargin,...
        'awsTrxUpload',false,...
        'wbObj',[]...
        );
      
      % Remote-train requires preProcData to be updated for all
      % training rows/images
      [tfsucc,obj.trnTblP] = obj.preretrain([],wbObj);
      if ~tfsucc
        obj.trnTblP = [];
        return;
      end
      
      % for images, deepnet will use preProcData; trx files however need
      % to be uploaded
      
      s = obj.lObj.trackCreateDeepTrackerStrippedLbl(obj.trnTblP);
      % check with Mayank, thought we wanted number of "underlying" chans
      % but DL is erring when pp data is grayscale but NumChans is 3
      s.cfg.NumChans = size(s.preProcData_I{1},3);
      
      tftrx = obj.lObj.hasTrx;
      
      ITRKER_SLBL = 2; % historical
      if tftrx
        assert(strcmp(s.trackerClass{ITRKER_SLBL},'DeepTracker'));
        assert(s.trackerData{ITRKER_SLBL}.trnNetType==obj.trnNetType);
        
        dlszx = s.trackerData{ITRKER_SLBL}.sPrm.sizex;
        dlszy = s.trackerData{ITRKER_SLBL}.sPrm.sizey;
        roirad = s.preProcParams.TargetCrop.Radius;
        szroi = 2*roirad+1;
        if dlszx~=szroi
          warningNoTrace('Target ROI Radius is %d while DeepTrack sizeX is %d. Setting sizeX to %d to match ROI Radius.',roirad,dlszx,szroi);
          s.trackerData{ITRKER_SLBL}.sPrm.sizex = szroi;
        end
        if dlszy~=szroi
          warningNoTrace('Target ROI Radius is %d while DeepTrack sizeY is %d. Setting sizeY to %d to match ROI Radius.',roirad,dlszy,szroi);
          s.trackerData{ITRKER_SLBL}.sPrm.sizey = szroi;
        end
      end
      
      if awsTrxUpload && tftrx
        % 1. The moviefiles in s should be not be used; deepnet should be
        % reading images directly from .preProcData_I. Fill s.movieFilesAll
        % with jibber as an assert.
        % 2. The trxfiles in s refer to local files; for AWS training we
        % will need them to refer to remote locs.
        %   a. For each trxfile that appears in the training data, we
        %      upload it and replace all appropriate rows of s.trxFilesAll.
        %   b. For all other rows of s.trxFilesAll, we replace with jibber
        %      as an assert.
                
        aws = backEnd.awsec2;
        aws.ensureRemoteDir('data','descstr','data');
        
        iMovTrn = unique(obj.trnTblP.mov); % must be regular mov, not GT
        
        assert(obj.nview==1,'Single-view only');
        IVIEW = 1;
        nmov = size(s.trxFilesAll,1);
        for iMov=1:nmov
          s.movieFilesAll{iMov,IVIEW} = '__UNUSED__';
          
          if any(iMov==iMovTrn)
            trxLclAbs = s.trxFilesAll{iMov,IVIEW};
            trxsha = DeepTracker.getSHA(trxLclAbs);
            trxRemoteRel = ['data/' trxsha];
            trxRemoteAbs = ['/home/ubuntu/' trxRemoteRel];
            aws.scpUploadOrVerify(trxLclAbs,trxRemoteRel,'trxfile'); % throws
            
            s.trxFilesAll{iMov,IVIEW} = trxRemoteAbs;
          else
            s.trxFilesAll{iMov,IVIEW} = '__UNUSED__';
          end          
        end
      end      
    end
    
    function trnAWSDownloadModel(obj) 
      nvw = obj.lObj.nview;
      trnID = obj.trnName;
      cacheDirLocal = obj.lObj.trackDLParams.CacheDir;
      backend = obj.lObj.trackDLBackEnd;
      aws = backend.awsec2;
      dmcs = obj.trnLastDMC;
            
      if isempty(trnID)
        error('Model has not been trained.');
      end
      
      assert(~isempty(cacheDirLocal),'CacheDir is unset/empty.');
      
      if isempty(aws)
        error('AWSec2 object not set.');
      end
      aws.checkInstanceRunning(); % harderrs if instance isn't running
      
      assert(numel(dmcs)==nvw);
      assert(nvw==1,'Multiview AWS train currently unsupported.');

      mdlFilesRemote = aws.remoteGlob(dmcs.keepGlobsLnx);
%       disp(mdlFilesRemote);
      mdlFilesRemote = setdiff(mdlFilesRemote,{dmcs.lblStrippedLnx}); % don't download/mirror this
      cacheDirLocalEscd = regexprep(cacheDirLocal,'\\','\\\\');
      mdlFilesLcl = regexprep(mdlFilesRemote,dmcs.rootDir,cacheDirLocalEscd);
      nfiles = numel(mdlFilesRemote);
      fprintf(1,'Downloading %d model files.\n',nfiles);
      for ifile=1:nfiles
        fsrc = mdlFilesRemote{ifile};
        fdst = mdlFilesLcl{ifile};
        if exist(fdst,'file')>0
          warningNoTrace('Local file ''%s'' exists. NOT downloading.',fdst);
        else
          aws.scpDownloadEnsureDir(fsrc,fdst,...
            'sysCmdArgs',{'dispcmd' true 'failbehavior' 'warn'});
        end
      end
    end
    
  end
  
  %% Track  
  methods
    
    % Tracking timeline
    % - Call to track. We are talking a single movie right now.
    % - .trnName must be set. The current backend behavior is the most 
    % recent model in <cache>/.../trnName will be used
    % - BG track monitor started. This polls the filesys for the output
    % file.
    % - Spawn track shell call.
    % - When tracking is done for a view, movIdx2trkfile is updated.
    % - When tracking is done for all views, we stop the bgMonitor and we
    % are done.
    
    function track(obj,tblMFT,varargin)
      % Apply trained tracker to the specified frames.
      % 
      % tblMFT: MFTable with cols MFTable.FLDSID
      
      if obj.bgTrkIsRunning
        error('Tracking is already in progress.');
      end
      if obj.bgTrnIsRunning && obj.lObj.trackDLBackEnd.type==DLBackEnd.AWS
        % second clause is really, "only have 1 GPU avail"
        % AWS, currently we are testing with p2.xlarge and p3.2xlarge which
        % are single-GPU EC2 instances. multi-GPU instances are avail
        % however.
        error('Tracking while training is in progress is currently unsupported on AWS.');
      end
      
      obj.bgTrkReset();
        
      % track an external movie
      if iscell(tblMFT),
        isexternal = true;
        movfiles = tblMFT;
        [trxfiles,trkfiles,f0,f1,cropRois,targets] = myparse(varargin,...
          'trxfiles',{},'trkfiles',{},'f0',[],'f1',[],'cropRois',{},'targets',{});
        assert(size(movfiles,2)==obj.lObj.nview,'movfiles must be nmovies x nviews');
        
        if obj.lObj.hasTrx,
          assert(all(size(trxfiles)==size(movfiles)),'Trx files must be input');
        end
        assert(all(size(trkfiles)==size(movfiles)),'Output trk files must be input');

        if isempty(cropRois),
          cropRois = repmat({CropInfo.empty(0,0)},size(movfiles,1),1);
        end
        
        if isempty(targets),
          targets = repmat({[]},[size(movfiles,1),1]);
        end
        
        trkfilesexist = cellfun(@exist,trkfiles);
        if any(trkfilesexist(:)),
          trkfilesdelete = trkfiles(trkfilesexist>0);
          res = questdlg([{'The following output trk files already exist. Delete them?'};trkfilesdelete(:)],'Delete existing trk files?','Delete','Cancel','Cancel');
          if strcmpi(res,'Delete'),
            for i = 1:numel(trkfilesdelete),
              delete(trkfilesdelete{i});
            end
          else
            return;
          end
        end
        
      else
        isexternal = false;
      end
      
      if ~isexternal && isempty(tblMFT)
        warningNoTrace('Nothing to track.');
        return;
      end
      
      if obj.bgTrnIsRunning,
        obj.updateLastDMCsCurrInfo();
        iterCurr = zeros(size(obj.trnLastDMC));
        for i = 1:numel(obj.trnLastDMC),
          ic = obj.trnLastDMC(i).iterCurr;
          if isempty(ic) || isnan(ic)
            iterCurr(i) = 0;
          else
            iterCurr(i) = ic;
          end
        end
        iterCurr = min(iterCurr);
        if iterCurr == 0,
          % AL updated msg to be palatable for both single and multi-views
          % (in the latter case you may have a tracker for one view but not
          % another)
          warndlg('Training in progress, and in-progress tracker(s) has not been saved yet. Please wait to track.','Tracker not ready','modal'); 
          return;
        end
        res = questdlg(sprintf('Training in progress. Tracking will use in-progress tracker, which has been trained for %d / %d iterations. When training completes, these frames will need to be retracked. Continue?',...
          iterCurr,obj.trnLastDMC(1).iterFinal),'Use in-progress tracker?','Track','Cancel','Track');
        if strcmpi(res,'Cancel'),
          return;
        end
      end
                    
      % check trained tracker
      if isempty(obj.trnName)
        error('No trained tracker found.');
      end      

      
      % are there tracking results from previous trackers? TODO This can be
      % moved under bgTrnIsRunning at some point, but right now there can
      % be mixed up tracking results, so let's always check. 
      if ~isexternal,
        isCurr = obj.checkTrackingResultsCurrent();
        if ~isCurr,
          
          res = questdlg('Tracking results exist for previous deep trackers. Delete these or retrack these frames?','Previous tracking results exist','Delete','Retrack','Cancel','Delete');
          if strcmpi(res,'Cancel'),
            return;
          end
          if strcmpi(res,'Retrack'),
            tblMFTRetrack = obj.getTrackedMFT();
            ism = ismember(tblMFTRetrack,tblMFT);
            tblMFT = [tblMFT;tblMFTRetrack(~ism,:)];
          end
          obj.cleanOutOfDateTrackingResults(isCurr);
          
        end
        
        % figure out what to track
        tblMFT = MFTable.sortCanonical(tblMFT);
        mIdx = unique(tblMFT.mov);
        if ~isscalar(mIdx)
          error('Tracking only single movies is currently supported.');
        end
        tMFTConc = obj.lObj.mftTableConcretizeMov(tblMFT);
        
        fprintf(1,'\n');
        
        tftrx = obj.lObj.hasTrx;
        if tftrx % can prob do away with this conditional
          f0 = min(tblMFT.frm);
          f1 = max(tblMFT.frm);
          % More complex version of warning below would apply
        else
          f0 = tblMFT.frm(1);
          f1 = tblMFT.frm(end);
          if ~isequal((f0:f1)',tblMFT.frm)
            warningNoTrace('Tracking additional frames to form continuous sequence.');
          end
        end
               
        if obj.lObj.cropProjHasCrops
          assert(~tftrx);
        cropInfo = obj.lObj.getMovieFilesAllCropInfoMovIdx(mIdx);
        cropRois = cat(1,cropInfo.roi);
        else
          cropRois = [];
        end
        
      end

      tfHeatMap = ~isempty(obj.trkGenHeatMaps) && obj.trkGenHeatMaps;
      if tfHeatMap
        hmapArgs = {'hmaps' true};
      else
        hmapArgs = {};
      end
      
      dmc = obj.trnLastDMC;
      dmcLcl = dmc.copy();
      [dmcLcl.rootDir] = deal(obj.lObj.trackDLParams.CacheDir);
      dlLblFileLcl = unique({dmcLcl.lblStrippedLnx});
      assert(isscalar(dlLblFileLcl));
      dlLblFileLcl = dlLblFileLcl{1};
      assert(exist(dlLblFileLcl,'file')>0);
      
      trkBackEnd = obj.lObj.trackDLBackEnd;
      switch trkBackEnd.type
        case {DLBackEnd.Bsub DLBackEnd.Docker}
          if isexternal,
            for movi = 1:size(movfiles,1),
              obj.trkSpawnBsubDocker(trkBackEnd,[],[],dlLblFileLcl,...
                cropRois{movi},hmapArgs,f0,f1,'movfiles',movfiles(movi,:),'trxfiles',trxfiles(movi,:),'targets',targets{movi},'trkfiles',trkfiles(movi,:));
            end
          else
            obj.trkSpawnBsubDocker(trkBackEnd,mIdx,tMFTConc,dlLblFileLcl,...
              cropRois,hmapArgs,f0,f1);
          end
        case DLBackEnd.AWS
          if isexternal,
            assert('Not implemented');
          else
            obj.trkSpawnAWS(trkBackEnd,mIdx,tMFTConc,dlLblFileLcl,cropRois,hmapArgs,f0,f1);
          end
        otherwise
          assert(false);
      end
    end
    
    function [tfCanTrack,reason] = canTrack(obj)
      tfCanTrack = false;
      reason = '';
      
      if obj.bgTrkIsRunning
        reason = 'Tracking is already in progress.';
        return;
      end

      % check trained tracker
      if isempty(obj.trnName)
        reason = 'No trained tracker found.';
        return;
      end
      
      if isempty(obj.sPrm),
        reason = 'Training parameters not set.';
        return;
      end

      cacheDir = obj.lObj.trackDLParams.CacheDir;
      if isempty(cacheDir)
        reason = 'Cache directory not set.';
        return;
      end
      
      dmc = obj.trnLastDMC;
      dmcLcl = dmc.copy();
      [dmcLcl.rootDir] = deal(cacheDir);
      dlLblFileLcl = unique({dmcLcl.lblStrippedLnx});
      assert(isscalar(dlLblFileLcl));
      dlLblFileLcl = dlLblFileLcl{1};
      if exist(dlLblFileLcl,'file')==0
        reason = sprintf('Cannot find training file: %s\n',dlLblFileLcl);
        return;
      end
      
      tfCanTrack = true;      
    end
    
    function trkSpawnBsubDocker(obj,backend,mIdx,tMFTConc,dlLblFile,...
        cropRois,hmapArgs,frm0,frm1,varargin)
      
      [movs,trxfiles,trxids,trkfiles] = myparse(varargin,'movfiles',{},'trxfiles',{},'targets',[],'trkfiles',{});
      isexternal = ~isempty(movs);

      % Currently mIdx, tMFTConc only one movie

      cacheDir = obj.lObj.trackDLParams.CacheDir;

      switch backend.type
        case DLBackEnd.Bsub
          DeepTracker.cloneJRCRepoIfNec(cacheDir);
          DeepTracker.updateAPTRepoExecJRC(cacheDir);
          aptjrcroot = [cacheDir '/APT'];
          hmapArgs = [hmapArgs {'deepnetroot' [aptjrcroot '/deepnet']}]; 
        case DLBackEnd.Docker
          
      end
      
      %obj.downloadPretrainedWeights();
      
      % put/ensure local stripped lbl
      dmc = obj.trnLastDMC;
      assert(isscalar(unique({dmc.lblStrippedLnx})));
      dlLblFile = dmc(1).lblStrippedLnx; 
      if exist(dlLblFile,'file')==0
        error('Cannot find stripped project file: %s\n',dlLblFile);
      end
      
      nView = obj.lObj.nview;
      
      tftrx = obj.lObj.hasTrx;
      tfcrop = ~isempty(cropRois);
      if tfcrop
        szassert(cropRois,[nView 4]);
      end
            
      if isexternal,
        assert(size(movs,2) == nView);
        mIdx = {movs,trxfiles};
      else
        movs = tMFTConc.mov;
        assert(size(movs,2)==nView);
        movs = movs(1,:);
      end
      nowstr = datestr(now,'yyyymmddTHHMMSS');
      modelChainID = obj.trnName;
      [trnstrs,modelFiles] = obj.getTrkFileTrnStr();
      %trnstr = sprintf('trn%s',modelChainID);
 
      % info for code-generation. for now we just record a struct so we can
      % more conveniently read logfiles etc. in future this could be an obj
      % that has a codegen method etc.
      trksysinfo = struct(...
        'trkfile',cell(nView,1),...
        'logfile',[],...
        'errfile',[],...
        'codestr',[]);
      for ivw=1:nView

        % base args
        baseargsaug = hmapArgs;
        modelFile = modelFiles{ivw};
        baseargsaug = [baseargsaug {'model_file' modelFile}]; %#ok<AGROW>
        if tfcrop
          baseargsaug = [baseargsaug {'croproi' cropRois(ivw,:)}]; %#ok<AGROW>
        end
        baseargsaug = [baseargsaug {'view' ivw}]; %#ok<AGROW> % 1-based OK
        if tftrx
          if isexternal,
            trxfile = trxfiles{1,ivw};
          else
            trxids = unique(tMFTConc.iTgt);
            trxfile = unique(tMFTConc.trxFile(:,ivw));
            assert(isscalar(trxfile));
            trxfile = trxfile{1};
          end
          baseargsaug = [baseargsaug {'trxtrk' trxfile 'trxids' trxids}]; %#ok<AGROW>
        else
          trxids = [];
        end
        
        % trkfile, outfile
        trkoutdir = dmc(ivw).dirTrkOutLnx;
        if exist(trkoutdir,'dir')==0
          [succ,msg] = mkdir(trkoutdir);
          if ~succ
            error('Failed to create trk cache dir %s: %s',trkoutdir,msg);
          else
            fprintf(1,'Created trk output dir: %s\n',trkoutdir);
          end
        end
        mov = movs{ivw};
        trnstr = trnstrs{ivw};
        [movP,movS] = fileparts(mov);
        defaulttrkfile = fullfile(trkoutdir,[movS '_' trnstr '_' nowstr '.trk']);
        if isexternal,
          trkfile = trkfiles{ivw};
        else
          trkfile = defaulttrkfile;
        end
        containerName = [movS '_' trnstr '_' nowstr];
        outfile = fullfile(trkoutdir,[movS '_' trnstr '_' nowstr '.log']);
        errfile = fullfile(trkoutdir,[movS '_' trnstr '_' nowstr '.err']);
        %outfile2 = fullfile(movP,[movS '_' trnstr '_' nowstr '.log2']);
        fprintf('View %d: trkfile will be written to %s\n',ivw,trkfile);  

        bsubargs = {'outfile' outfile};
        %sshargs = {'logfile' outfile2};
        sshargs = {};
        trksysinfo(ivw).trkfile = trkfile;
        trksysinfo(ivw).logfile = outfile;
        trksysinfo(ivw).errfile = errfile;
        trksysinfo(ivw).parttrkfile = [defaulttrkfile,'.part'];

        %trksysinfo(ivw).logfilessh = outfile2;
        
        switch backend.type
          case DLBackEnd.Bsub
            singBind = obj.genContainerMountPath('aptroot',aptjrcroot);
            singargs = {'bindpath',singBind};
            trksysinfo(ivw).codestr = DeepTracker.trackCodeGenSSHBsubSing(...
              modelChainID,dmc(ivw).rootDir,dlLblFile,errfile,obj.trnNetType,...
              mov,trkfile,frm0,frm1,...
              'baseargs',baseargsaug,'singArgs',singargs,'bsubargs',bsubargs,...
              'sshargs',sshargs);

          case DLBackEnd.Docker
            singBind = obj.genContainerMountPath();
            [trksysinfo(ivw).codestr,trksysinfo(ivw).containerName] = ...
              DeepTracker.trackCodeGenDocker(...
              modelChainID,dmc(ivw).rootDir,dlLblFile,errfile,obj.trnNetType,...
              mov,trkfile,frm0,frm1,...
              'baseargs',baseargsaug,'mntPaths',singBind,'containerName',containerName);
            trksysinfo(ivw).logcmd = sprintf('docker logs -f %s &> %s &',...
              trksysinfo(ivw).containerName,...
              outfile);
        end
      end
            
      if obj.dryRunOnly
        arrayfun(@(x)fprintf(1,'Dry run, not tracking: %s\n',x.codestr),...
          trksysinfo);
      else
         % start track monitor
        assert(isempty(obj.bgTrkMonitor));
        
        outfiles = {trksysinfo.trkfile}';
        logfiles = {trksysinfo.logfile}';
        errfiles = {trksysinfo.errfile}';
        partfiles = {trksysinfo.parttrkfile}';
        bgTrkWorkerObj = BgTrackWorkerObjBsub(nView,dmc);
        bgTrkWorkerObj.initFiles(mIdx,movs,outfiles,...
          logfiles,errfiles,partfiles);
        
        tfErrFileErr = cellfun(@bgTrkWorkerObj.errFileExistsNonZeroSize,errfiles);
        if any(tfErrFileErr)
          error('There is an existing error in an error file: ''%s''.',...
            String.cellstr2CommaSepList(errfiles));
        end

        bgTrkMonitorObj = BgTrackMonitor;
        
        % KB 20190115: adding trkviz
        nvw = obj.lObj.nview;
        % figure out how many frames are to be tracked
        %nFramesTrack = size(tMFTConc,1); % this is inaccurate
        nFramesTrack = obj.getNFramesTrack(tMFTConc,mIdx,frm0,frm1,trxids);
        fprintf('Requested to track %d frames, through interface will track %d frames.\n',size(tMFTConc,1),nFramesTrack)
        
        trkVizObj = feval(obj.bgTrkMonitorVizClass,nvw,obj,bgTrkWorkerObj,backend.type,nFramesTrack);   
        bgTrkMonitorObj.prepare(trkVizObj,bgTrkWorkerObj,...
          @obj.trkCompleteCbk);

        addlistener(bgTrkMonitorObj,'bgStart',@(s,e)obj.notify('trackStart'));
        addlistener(bgTrkMonitorObj,'bgEnd',@(varargin) obj.trackStoppedCbk(varargin{:}));
        
        %bgTrkMonitorObj.prepare(bgTrkWorkerObj,@obj.trkCompleteCbk);
        obj.bgTrkStart(bgTrkMonitorObj,bgTrkWorkerObj);
        
        % spawn jobs
        for ivw=1:nView
          fprintf(1,'%s\n',trksysinfo(ivw).codestr);
          [st,res] = system(trksysinfo(ivw).codestr);
          if st==0
            bgTrkWorkerObj.parseJobID(res,ivw);
            fprintf('Tracking job (view %d) spawned:\n%s\n',ivw,res);
          else
            fprintf(2,'Failed to spawn tracking job for view %d: %s.\n\n',...
              ivw,res);
          end
          switch backend.type,
            case DLBackEnd.Docker,
              [st,res] = system(trksysinfo(ivw).logcmd);
              if st~=0,
                fprintf(2,'Error logging docker job %s: %s\n',trksysinfo(ivw).containerName,res);
              end
          end
        end
        
        obj.trkSysInfo = trksysinfo;
      end      
    end
    function nframes = getNFramesTrack(obj,tMFTConc,mIdx,frm0,frm1,trxids)
      
      isexternal = iscell(mIdx);
      if isexternal,

        movs = mIdx{1};
        trxfiles = mIdx{2};
        nfrm = MovieReader.getNFrames(movs{1});
        if isempty(frm1),
          frm0 = 1;
          frm1 = nfrm;
        end
        if isempty(trxfiles),
          nframes = frm1-frm0+1;
        else
          [~,frm2trx] = obj.lObj.getTrx(trxfiles{1},nfrm);          
          if isempty(trxids),
            trxids = 1:size(frm2trx,2);
          end
          nframes = sum(sum(frm2trx(frm0:frm1,trxids)));
        end
        
      else
        
        if isempty(trxids),
          nframes = frm1-frm0+1;
        else
          if mIdx == obj.lObj.currMovIdx,
            frm2trx = obj.lObj.frm2trx;
          else
            iMov = double(mIdx);
            nfrm = obj.lObj.movieInfoAllGTaware{iMov,1}.nframes;
            trxFile = obj.lObj.trxFilesAllFullGTaware{mIdx,1};
            [~,frm2trx] = obj.lObj.getTrx(trxFile,nfrm);
          end
          nframes = sum(sum(frm2trx(frm0:frm1,trxids)));
        end
      end
    end

  end
  methods (Static)
    function sha = getSHA(file)
      file = strrep(file,' ','\ ');
      if ismac
        shacmd = sprintf('MD5 %s',file);
        [~,res] = AWSec2.syscmd(shacmd,'dispcmd',true,'failbehavior','err');
        res = strtrim(res);
        toks = regexp(res,' ','split');
        sha = toks{end};        
        sha = regexprep(sha,' ','');          
      elseif isunix
        shacmd = sprintf('md5sum %s',file);
        [~,res] = AWSec2.syscmd(shacmd,'dispcmd',true,'failbehavior','err');
        toks = regexp(res,' ','split');
        sha = toks{1};        
        sha = regexprep(sha,' ','');
      else
        shacmd = sprintf('certUtil -hashFile %s MD5',file);
        [~,res] = AWSec2.syscmd(shacmd,'dispcmd',true,'failbehavior','err');
        toks = regexp(res,'\n','split');
        sha = toks{2};
        sha = regexprep(sha,' ','');
      end
    end
  end
  methods
    function trkSpawnAWS(obj,backend,mIdx,tMFTConc,dlLblFileLcl,cropRois,hmapArgs,...
        frm0,frm1)
      % Currently mIdx, tMFTConc only one movie
      
      nvw = obj.lObj.nview;
      assert(nvw==1,'Tracking with AWS currently supports only single-view projects.');

      aws = backend.awsec2;
      aws.checkInstanceRunning(); % harderrs if instance isn't running
%       fprintf('AWS EC2 instance id %s is running...\n\n',aws.instanceID);
            
      DeepTracker.updateAPTRepoExecAWS(aws);
      
      % put/ensure remote stripped lbl
      dmc = obj.trnLastDMC;
      dlLblFileRemote = dmc.lblStrippedLnx;
      aws.scpUploadOrVerifyEnsureDir(dlLblFileLcl,dlLblFileRemote,'training file');
            
      %trkdirRemoteFull = aws.ensureRemoteDir('trk','descstr','trk');
      datadirRemoteFull = aws.ensureRemoteDir('data','descstr','data');
      % should prob get these from tMFTConc
      movsfull = obj.lObj.getMovieFilesAllFullMovIdx(mIdx);
      trxsfull = obj.lObj.getTrxFilesAllFullMovIdx(mIdx);
      tftrx = obj.lObj.hasTrx;
      tfcrop = ~isempty(cropRois);
      if tfcrop
        szassert(cropRois,[nvw 4]);
      end
      
      [trnstrs,modelFiles] = obj.getTrkFileTrnStr();
      
      trksysinfo = struct(...
        'trkfilelocal',cell(nvw,1),...
        'trkfileremote',[],...
        'logfile',[],...
        'codestr',[],...
        'syscmd',[]);
      
      for ivw=1:nvw
        
        % upload mov/trx as nec
        mov = movsfull{ivw};
        [~,~,movE] = fileparts(mov);
        movsha = DeepTracker.getSHA(mov);
        movRemoteRel = ['data/' movsha movE];
        movRemoteAbs = ['~/' movRemoteRel];
        aws.scpUploadOrVerify(mov,movRemoteRel,'movie'); % throws            
        if tftrx
          trx = trxsfull{ivw};
          trxsha = DeepTracker.getSHA(trx);
          trxRemoteRel = ['data/' trxsha];
          trxRemoteAbs = ['~/' trxRemoteRel];
          aws.scpUploadOrVerify(trx,trxRemoteRel,'trxfile'); % throws            
        end
              
        % DL track args
        baseargsaug = hmapArgs;
        modelFile = modelFiles{ivw};
        baseargsaug = [baseargsaug {'model_file' modelFile}]; %#ok<AGROW>
        if tfcrop
          baseargsaug = [baseargsaug {'croproi' cropRois(ivw,:)}]; %#ok<AGROW>
        end
        baseargsaug = [baseargsaug {'view' ivw}]; %#ok<AGROW> % 1-based OK
        if tftrx
          trxids = unique(tMFTConc.iTgt);
          baseargsaug = [baseargsaug {'trxtrk' trxRemoteAbs 'trxids' trxids}]; %#ok<AGROW>
        end
        
        % trk/log names, local and remote
        nowstr = datestr(now,'yyyymmddTHHMMSS');
        modelChainID = obj.trnName;
        %trnstr = sprintf('trn%s',modelChainID);
        
        trkdirRemote = dmc(ivw).dirTrkOutLnx;
        aws.ensureRemoteDir(trkdirRemote,'relative',false,'descstr','trk');
        dmcLcl = dmc(ivw).copy();
        dmcLcl.rootDir = obj.lObj.trackDLParams.CacheDir;
        trkdirLocal = dmcLcl.dirTrkOutLnx;
        if exist(trkdirLocal,'dir')==0
          [succ,msg] = mkdir(trkdirLocal);
          if ~succ
            error('Failed to create local trk cache dir %s: %s',trkdirLocal,msg);
          else
            fprintf(1,'Created local trk cache dir: %s\n',trkdirLocal);
          end
        end
      
        [~,movS,movE] = myfileparts(mov);
        trnstr = trnstrs{ivw};
        trkLocalRel = [movS '_' trnstr '_' nowstr '.trk'];
        trkRemoteRel = [movsha '_' trnstr '_' nowstr];
        trkLocalAbs = fullfile(trkdirLocal,trkLocalRel);
        trkRemoteAbs = [trkdirRemote '/' trkRemoteRel '.trk'];
        logfileRemoteAbs = [trkdirRemote '/' trkRemoteRel '.log'];
        errfileRemoteAbs = [trkdirRemote '/' trkRemoteRel '.err'];
        %outfile2 = [trkdirRemoteFull '/' trkfilebase '.log2'];
        %fprintf('View %d: trkfile will be written to %s\n',ivw,trkfile);
        
        codestr = DeepTracker.trackCodeGenAWS(...
          modelChainID,dmc(ivw).rootDir,dlLblFileRemote,errfileRemoteAbs,...
          obj.trnNetType,movRemoteAbs,trkRemoteAbs,frm0,frm1,baseargsaug);
        
        trksysinfo(ivw).trkfilelocal = trkLocalAbs;
        trksysinfo(ivw).trkfileremote = trkRemoteAbs;
        
        trksysinfo(ivw).parttrkfilelocal = [trkLocalAbs,'.part'];
        trksysinfo(ivw).parttrkfileremote = [trkRemoteAbs,'.part'];
        
        trksysinfo(ivw).logfile = logfileRemoteAbs;
        trksysinfo(ivw).errfile = errfileRemoteAbs;
        trksysinfo(ivw).codestr = codestr;
        trksysinfo(ivw).syscmd = aws.sshCmdGeneralLogged(codestr,logfileRemoteAbs);
      end
        
      if obj.dryRunOnly
        arrayfun(@(x)fprintf(1,'Dry run, not tracking: %s\n',x.syscmd),...
          trksysinfo);
      else
        % start track monitor
        assert(isempty(obj.bgTrkMonitor));

        trkfilesLocal = {trksysinfo.trkfilelocal}';
        trkfilesRemote = {trksysinfo.trkfileremote}';
        logfiles = {trksysinfo.logfile}';
        errfiles = {trksysinfo.errfile}';
        % KB: not sure what to do with part files remote vs local yet
        partfilesRemote = {trksysinfo.parttrkfileremote}';
        partfilesLocal = {trksysinfo.parttrkfilelocal}';

        bgTrkWorkerObj = BgTrackWorkerObjAWS(nvw,dmc,aws);

        bgTrkWorkerObj.initFiles(mIdx,movsfull,...
          trkfilesRemote,logfiles,errfiles,partfilesRemote);
        
        tfErrFileErr = cellfun(@bgTrkWorkerObj.errFileExistsNonZeroSize,errfiles);
        if any(tfErrFileErr)
          error('There is an existing error in an error file: ''%s''.',...
            String.cellstr2CommaSepList(errfiles));
        end
                
        bgTrkMonitorObj = BgTrackMonitor;

        % KB 20190115: adding trkviz
        nvw = obj.lObj.nview;
        % figure out how many frames are to be tracked
        nFramesTrack = size(tMFTConc,1);

        trkVizObj = feval(obj.bgTrkMonitorVizClass,nvw,obj,bgTrkWorkerObj,backend.type,nFramesTrack);   
        bgTrkMonitorObj.prepare(trkVizObj,bgTrkWorkerObj,...
          @(x)obj.trkCompleteCbkAWS(backend,trkfilesLocal,x));

        addlistener(bgTrkMonitorObj,'bgStart',@(s,e)obj.notify('trackStart'));
        addlistener(bgTrkMonitorObj,'bgEnd',@(s,e)obj.notify('trackEnd'));
        
        obj.bgTrkStart(bgTrkMonitorObj,bgTrkWorkerObj);
        
        % spawn jobs
        for ivw=1:nvw
          syscmd = trksysinfo(ivw).syscmd;
          fprintf(1,'%s\n',syscmd);
          if ivw>1
            fprintf(2,'Skipping spawn view %d\n',ivw);
            continue;
          end
          
          system(syscmd);     
          fprintf('Tracking job (view %d) spawned.\n\n',ivw);

          pause(1.0); % Hack try to more reliably get PID
          aws.getRemotePythonPID();
        end
        
        obj.trkSysInfo = trksysinfo;
      end
    end
    
    function trkPrintLogs(obj)
      btm = obj.bgTrkMonitor;
      if isempty(btm)
        error('Tracking is neither in progress nor complete.');
      end
      btm.bgWorkerObj.printLogfiles();
    end
    
    function bgTrkReset(obj)
      obj.trkSysInfo = [];
      if ~isempty(obj.bgTrkMonitor)
        delete(obj.bgTrkMonitor);
      end
      obj.bgTrkMonitor = [];
      if ~isempty(obj.bgTrkMonBGWorkerObj)
        delete(obj.bgTrkMonBGWorkerObj);
      end
      obj.bgTrkMonBGWorkerObj = [];
    end
    
    function bgTrkStart(obj,trkMonitorObj,trkWorkerObj)
      % fresh start new training monitor 
      % trkMonitorObj: should be 'prepared'
      
      if ~isempty(obj.bgTrkMonitor)
        error('Tracking monitor exists. Call .bgTrkReset first to stop/remove existing monitor.');
      end
      assert(isempty(obj.bgTrkMonBGWorkerObj));
      
      trkMonitorObj.start();
      obj.bgTrkMonitor = trkMonitorObj;
      obj.bgTrkMonBGWorkerObj = trkWorkerObj;
    end
    
    function trkCompleteCbk(obj,res)
      
      isexternal = iscell(res.mIdx);
      if isexternal,
        fprintf('Tracking complete for %s, results saved to %s.\n',res.movfile,res.trkfile);
        return;
      end
      mIdx = [res.mIdx];
      assert(all(mIdx==mIdx(1)));
      mIdx = res(1).mIdx;
      movsFull = obj.lObj.getMovieFilesAllFullMovIdx(mIdx);
      if all(strcmp(movsFull(:),{res.movfile}'))
        % we perform this check b/c while tracking has been running in
        % the bg, the project could have been updated, movies
        % renamed/reordered etc.
        obj.trackResAddTrkfile(mIdx,{res.trkfile}');
        if mIdx==obj.lObj.currMovIdx
          obj.trackCurrResUpdate();
          obj.newLabelerFrame();
          fprintf('Tracking complete for current movie at %s.\n',datestr(now));
        else
          iMov = mIdx.get();
          fprintf('Tracking complete for movie %d at %s.\n',iMov,datestr(now));
        end
      else
        warningNoTrace('Tracking complete, but movieset %d has changed in current project.',...
          int32(mIdx));
        % conservative, take no action for now
      end
    end

    function trkCompleteCbkAWS(obj,backend,trkfilesLocal,res)
      assert(numel(trkfilesLocal)==numel(res));
 
      mIdx = [res.mIdx];
      assert(all(mIdx==mIdx(1)));
      mIdx = res(1).mIdx;
      movsFull = obj.lObj.getMovieFilesAllFullMovIdx(mIdx);
      if all(strcmp(movsFull(:),{res.movfile}'))
        % we perform this check b/c while tracking has been running in
        % the bg, the project could have been updated, movies
        % renamed/reordered etc.
        
        aws = backend.awsec2;
        
        % download trkfiles 
        sysCmdArgs = {'dispcmd' true 'failbehavior' 'err'};
        for ivw=1:numel(res)
          trkLcl = trkfilesLocal{ivw};
          trkRmt = res(ivw).trkfile;
          aws.scpDownload(trkRmt,trkLcl,'sysCmdArgs',sysCmdArgs);
        end
        
        obj.trackResAddTrkfile(mIdx,trkfilesLocal);
        if mIdx==obj.lObj.currMovIdx
          obj.trackCurrResUpdate();
          obj.newLabelerFrame();
          fprintf('Tracking complete for current movie at %s.\n',datestr(now));
        else
          iMov = mIdx.get();
          fprintf('Tracking complete for movie %d at %s.\n',iMov,datestr(now));
        end
      else
        warningNoTrace('Tracking complete, but movieset %d has changed in current project.',...
          int32(mIdx));
        % conservative, take no action for now
      end
    end

    function trainStoppedCbk(obj,varargin)
      obj.trainCleanup();
      obj.notify('trainEnd');
    end
    
    function trackStoppedCbk(obj,varargin)
      obj.trackCleanup();
      obj.notify('trackEnd');
    end

    function trackCleanup(obj,varargin)
      
      obj.trackCurrResUpdate();
      obj.newLabelerFrame();

    end
    
    function trainCleanup(obj,varargin)

      if obj.bgTrkIsRunning,
        fprintf('Stopping tracking...\n');
        obj.bgTrkMonitor.stop();
        obj.bgTrkMonitor.reset();
        assert(~obj.bgTrkIsRunning);
      end

      obj.trackCurrResUpdate();
      obj.newLabelerFrame();
      
      % are there tracking results from previous trackers? TODO This can be
      % moved under bgTrnIsRunning at some point, but right now there can
      % be mixed up tracking results, so let's always check. 
      isCurr = obj.checkTrackingResultsCurrent();
      if ~isCurr,
        
        res = questdlg('Tracking results exist for previous deep trackers. Delete these or retrack these frames?','Previous tracking results exist','Delete','Retrack','Delete');
        obj.cleanOutOfDateTrackingResults(isCurr);
        obj.trackCurrResUpdate();
        obj.newLabelerFrame();
        if strcmpi(res,'Retrack'),
          tblMFTRetrack = obj.getTrackedMFT();
          obj.track(tblMFTRetrack);
        end

      end
    end
    
    function [trnstrs,modelFiles] = getTrkFileTrnStr(obj)      
      obj.updateLastDMCsCurrInfo();
      
      trnstrs = cell(size(obj.trnLastDMC));
      modelFiles = cell(size(obj.trnLastDMC));
      for i = 1:numel(obj.trnLastDMC),
        trnstrs{i} = sprintf('trn%s_iter%d',obj.trnName,obj.trnLastDMC(i).iterCurr);
        modelFiles{i} = obj.trnLastDMC(i).trainCurrIndexLnx;
        modelFiles{i} = regexprep(modelFiles{i},'\.index$','');
      end
    end
    
  end
  methods (Static) % train/track codegen
    
    function downloadPretrainedWeights(varargin) 
      aptroot = myparse(varargin,...
        'aptroot',APT.Root...
        );
      
      urlsAll = DeepTracker.pretrained_weights_urls;
      weightfilepats = DeepTracker.pretrained_weights_files_pat_lnx;
      deepnetrootlnx = [aptroot '/deepnet'];
      pretrainedlnx = [deepnetrootlnx '/pretrained'];
      for i = 1:numel(urlsAll)
        url = urlsAll{i};
        pat = weightfilepats{i};
        wfile = sprintf(pat,deepnetrootlnx);

        if exist(wfile,'file')>0
          fprintf('Tensorflow resnet pretrained weights %s already downloaded.\n',url);
          continue;
        end
          
        % hmm what happens when the weightfilenames change?
        fprintf('Downloading tensorflow resnet pretrained weights %s (APT)..\n',url);
        outfiles = untar(url,pretrainedlnx);
        sprintf('Downloaded and extracted the following files/directories:\n');
        fprintf('%s\n',outfiles{:});
      end      
    end
    function codestr = codeGenSSHGeneral(remotecmd,varargin)
      [host,bg,prefix,sshoptions] = myparse(varargin,...
        'host',DeepTracker.jrchost,... % 'logfile','/dev/null',...
        'bg',true,...
        'prefix',DeepTracker.jrcprefix,...
        'sshoptions','-o "StrictHostKeyChecking no"');
      
      if ~isempty(prefix),
        remotecmd = [prefix,'; ',remotecmd];
      end
      if ~ischar(sshoptions) || isempty(sshoptions),
        sshcmd = 'ssh';
      else
        sshcmd = ['ssh ',sshoptions];
      end
            
      if bg
        codestr = sprintf('%s %s ''%s </dev/null &''',sshcmd,host,remotecmd);
      else
        codestr = sprintf('%s %s ''%s''',sshcmd,host,remotecmd);
      end

%       codestr = sprintf('ssh %s ''%s </dev/null >%s 2>&1 &''',...
%         host,remotecmd,logfile);    
    end
    function codestr = codeGenSingGeneral(basecmd,varargin)
      % Take a base command and run it in a sing img
      DFLTBINDPATH = {
        '/groups/branson/bransonlab'
        '/groups/branson/home'
        '/nrs/branson'
        '/scratch'};      
      [bindpath,singimg] = myparse(varargin,...
        'bindpath',DFLTBINDPATH,...
        'singimg','/misc/local/singularity/branson_v2.simg');
      
      Bflags = [repmat({'-B'},1,numel(bindpath)); bindpath(:)'];
      Bflagsstr = sprintf('%s ',Bflags{:});
      codestr = sprintf('singularity exec --nv %s %s bash -c ". /opt/venv/bin/activate && %s"',...
        Bflagsstr,singimg,basecmd);
    end
    
    function codestr = codeGenDockerGeneral(basecmd,containerName,varargin)
      % Take a base command and run it in a sing img
      DFLTBINDPATH = {};
      [bindpath,dockerimg,gpuid] = myparse(varargin,...
        'bindpath',DFLTBINDPATH,...
        'dockerimg','bransonlabapt/apt_docker',...
        'gpuid',0);
      
      mountArgs = cellfun(@(x)sprintf('--mount ''type=bind,src=%s,dst=%s''',x,x),...
        bindpath,'uni',0);
      
      homedir = getenv('HOME');
      aptdeepnet = APT.getpathdl;
      codestr = [
        {
        'docker run'
        '-d'
        sprintf('--name %s',containerName);
        '--runtime nvidia'
        '--rm'
        };
        mountArgs(:);
        {
        '--user $(id -u)'
        '-w $PWD'
        dockerimg
        sprintf('bash -c "export HOME=%s; export CUDA_VISIBLE_DEVICES=%d; cd %s; %s"',...
          homedir,gpuid,aptdeepnet,basecmd);
        }
      ];
    
      codestr = sprintf('%s ',codestr{:});
      codestr = codestr(1:end-1);
    end

    
    function codestr = codeGenBsubGeneral(basecmd,varargin)
      [nslots,gpuqueue,outfile] = myparse(varargin,...
        'nslots',1,...
        'gpuqueue','gpu_any',...
        'outfile','/dev/null');
      codestr = sprintf('bsub -n %d -gpu "num=1" -q %s -o %s %s',...
        nslots,gpuqueue,outfile,basecmd);      
    end
    function codestr = trainCodeGen(trnID,dllbl,cache,errfile,netType,...
        varargin)
      [view,deepnetroot,trainType] = myparse(varargin,...
        'view',[],... % (opt) 1-based view index. If supplied, train only that view. If not, all views trained serially
        'deepnetroot',APT.getpathdl,...
        'trainType',DLTrainType.New...
          );
      tfview = ~isempty(view);
      
      aptintrf = [deepnetroot '/APT_interface.py'];
      
      switch trainType
        case DLTrainType.New
          continueflags = '';
        case DLTrainType.Restart
          continueflags = '-continue -skip_db';
        case DLTrainType.RestartAug
          continueflags = '-continue';
        otherwise
          assert(false);
      end
      
      codestr = sprintf('python %s -name %s',aptintrf,trnID);
      if tfview
        codestr = sprintf('%s -view %d',codestr,view); % APT_interface accepts 1-based view
      end      
      codestr = sprintf('%s -cache %s -err_file %s -type %s %s train -use_cache %s',...
        codestr,cache,errfile,netType,dllbl,continueflags);
    end
    function [codestr,containerName] = trainCodeGenDocker(modelChainID,trainID,...
        dllbl,cache,errfile,netType,trainType,view1b,mntPaths,varargin)
                  
      [dockerargs] = myparse(varargin,'dockerargs',{});
      %fprintf(2,'TODO: restart/trainType\n');
      %baseargs = {'view' view1b};
      baseargs = {'view' view1b 'trainType' trainType};

      basecmd = DeepTracker.trainCodeGen(modelChainID,dllbl,cache,errfile,...
        netType,baseargs{:});

      containerName = [modelChainID '_' trainID];      
     
      codestr = DeepTracker.codeGenDockerGeneral(basecmd,containerName,...
        'bindpath',mntPaths,dockerargs{:});
      
    end
    function [codestr,containerName] = trainCodeGenDockerDMC(dmc,mntPaths)
      [codestr,containerName] = DeepTracker.trainCodeGenDocker(...
        dmc.modelChainID,dmc.trainID,dmc.lblStrippedLnx,...
        dmc.rootDir,dmc.errfileLnx,dmc.netType,dmc.trainType,dmc.view+1,mntPaths);
    end
    function codestr = trainCodeGenSing(trnID,dllbl,cache,errfile,netType,...
        varargin)
      [baseargs,singargs] = myparse(varargin,...
        'baseargs',{},...
        'singargs',{});
      basecmd = DeepTracker.trainCodeGen(trnID,dllbl,cache,errfile,...
        netType,baseargs{:});
      codestr = DeepTracker.codeGenSingGeneral(basecmd,singargs{:});
    end
    function codestr = trainCodeGenBsubSing(trnID,dllbl,cache,errfile,...
        netType,varargin)
      [baseargs,singargs,bsubargs] = myparse(varargin,...
        'baseargs',{},...
        'singargs',{},...
        'bsubargs',{});
      basecmd = DeepTracker.trainCodeGenSing(trnID,dllbl,cache,errfile,...
        netType,'baseargs',baseargs,'singargs',singargs);
      codestr = DeepTracker.codeGenBsubGeneral(basecmd,bsubargs{:});
    end    
    function codestr = trainCodeGenSSHBsubSing(trnID,dllbl,cache,errfile,...
        netType,varargin)
      [baseargs,singargs,bsubargs,sshargs] = myparse(varargin,...
        'baseargs',{},...
        'singargs',{},...
        'bsubargs',{},...
        'sshargs',{});
      remotecmd = DeepTracker.trainCodeGenBsubSing(trnID,dllbl,cache,...
        errfile,netType,...
        'baseargs',baseargs,'singargs',singargs,'bsubargs',bsubargs);
      codestr = DeepTracker.codeGenSSHGeneral(remotecmd,sshargs{:});
    end
    function codestr = trainCodeGenSSHBsubSingDMC(dmc,varargin)
      singargs = myparse(varargin,...
        'singargs',{}...
        );
      
      repoSSscriptLnx = [dmc.dirAptRootLnx '/repo_snapshot.sh'];
      repoSScmd = sprintf('%s %s > %s',repoSSscriptLnx,dmc.dirAptRootLnx,dmc.aptRepoSnapshotLnx);
      prefix = [DeepTracker.jrcprefix '; ' repoSScmd];
      
      codestr = DeepTracker.trainCodeGenSSHBsubSing(...
        dmc.modelChainID,dmc.lblStrippedLnx,...
        dmc.rootDir,dmc.errfileLnx,dmc.netType,...
        'baseArgs',{'view' dmc.view+1 'trainType' dmc.trainType 'deepnetroot' [dmc.rootDir '/APT/deepnet']},...
        'singargs',singargs,...
        'bsubArgs',{'outfile' dmc.trainLogLnx},...
        'sshargs',{'prefix' prefix});
    end
      
    function codestr = updateAPTRepoCmd(varargin)
      aptparent = myparse(varargin,...
        'aptparent','/home/ubuntu');
      
      aptroot = [aptparent '/APT/deepnet'];
      
      codestr = {
        sprintf('cd %s;',aptroot);
        'git checkout develop;';
        'git pull;'; 
        };
      codestr = cat(2,codestr{:});
    end
    function updateAPTRepoExecAWS(aws) % throws if fails
      cmdremote = DeepTracker.updateAPTRepoCmd();
      [tfsucc,res] = aws.cmdInstance(cmdremote,'dispcmd',true); %#ok<ASGLU>
      if tfsucc
        fprintf('Updated remote APT repo.\n\n');
      else
        error('Failed to update remote APT repo.');
      end
    end
    function updateAPTRepoExecJRC(cacheRoot) % throws if fails
      % cacheRoot: 'remote' cachedir, ie cachedir on JRC filesys
      updatecmd = DeepTracker.updateAPTRepoCmd('aptparent',cacheRoot);
      updatecmd = DeepTracker.codeGenSSHGeneral(updatecmd,'bg',false);
      [~,res] = AWSec2.syscmd(updatecmd,...
        'dispcmd',true,...
        'failbehavior','err');
    end
    function cmd = cpPTWfromJRCProdLnx(cacheRoot)
      % copy cmd (lnx) deepnet/pretrained from production repo to JRC loc 
      srcPTWlnx = [DeepTracker.jrcprodrepo '/deepnet/pretrained'];
      dstPTWlnx = [cacheRoot '/APT/deepnet'];      
      cmd = sprintf('cp -r -u %s %s',srcPTWlnx,dstPTWlnx);
    end
    function cpupdatePTWfromJRCProdExec(cacheRoot) % throws if errors
      cmd = DeepTracker.cpPTWfromJRCProdLnx(cacheRoot);
      cmd = DeepTracker.codeGenSSHGeneral(cmd,'bg',false);
      [~,res] = AWSec2.syscmd(cmd,...
        'dispcmd',true,...
        'failbehavior','err');
    end
    function cmd = dirExistsCmd(ddir)
      cmd = sprintf('bash -c "[ -d ''%s'' ] && echo ''y'' || echo ''n''"',ddir);
    end      
    function cloneJRCRepoIfNec(cacheRoot) % throws on fail
      % Clone 'remote' repo into cacheRoot from prod, if necessary
      % 
      % cacheRoot: 'remote' cachedir, ie cachedir on JRC filesys
      
      % does repo in 'remote' cache exist?
      aptroot = [cacheRoot '/APT'];
      aptrootexistscmd = DeepTracker.dirExistsCmd(aptroot);
      aptrootexistscmd = DeepTracker.codeGenSSHGeneral(aptrootexistscmd,...
        'bg',false);
      
      [~,res] = AWSec2.syscmd(aptrootexistscmd,...
        'dispcmd',true,...
        'failbehavior','err');
      res = strtrim(res);
      
      % clone it if nec
      switch res
        case 'y'
          fprintf('Found JRC/APT repo at %s.\n',aptroot);
        case 'n'
          cloneaptcmd = sprintf('git clone %s %s',DeepTracker.jrcprodrepo,aptroot);
          cloneaptcmd = DeepTracker.codeGenSSHGeneral(cloneaptcmd,'bg',false);
          [~,res] = AWSec2.syscmd(cloneaptcmd,...
            'dispcmd',true,...
            'failbehavior','err');
          fprintf('Cloned JRC/APT repo into %s.\n',aptroot);
        otherwise
          error('Failed to update APT repo on JRC filesystem.');
      end
    end
          
    function codestr = trainCodeGenAWS(dmc)      
      % not sure what -name flag does exactly
      
      codestr = DeepTracker.trainCodeGen(...
        dmc.modelChainID,dmc.lblStrippedLnx,dmc.rootDir,...
        dmc.errfileLnx,char(dmc.netType),...
        'view',dmc.view+1,...
        'deepnetroot','/home/ubuntu/APT/deepnet',...
        'trainType',dmc.trainType);        
        
      codestr = {
        'cd /home/ubuntu/APT/deepnet;';
        'export LD_LIBRARY_PATH=/home/ubuntu/src/cntk/bindings/python/cntk/libs:/usr/local/cuda/lib64:/usr/local/lib:/usr/lib:/usr/local/cuda/extras/CUPTI/lib64:/usr/local/mpi/lib;';
        codestr;
        };
      codestr = cat(2,codestr{:});
    end
    function codestr = trackCodeGenBase(trnID,dllbl,errfile,nettype,movtrk,...
        outtrk,frm0,frm1,varargin)
      [cache,trxtrk,trxids,view,croproi,hmaps,deepnetroot,model_file] = myparse(varargin,...
        'cache',[],... % (opt) cachedir
        'trxtrk','',... % (opt) trkfile for movtrk to be tracked 
        'trxids',[],... % (opt) 1-based index into trx structure in trxtrk. empty=>all trx
        'view',[],... % (opt) 1-based view index. If supplied, track only that view. If not, all views tracked serially 
        'croproi',[],... % (opt) 1-based [xlo xhi ylo yhi] roi (inclusive)
        'hmaps',false,...% (opt) if true, generate heatmaps
        'deepnetroot',APT.getpathdl,...
        'model_file',[]...
        ); 
     
      tfcache = ~isempty(cache);
      tftrx = ~isempty(trxtrk);
      tftrxids = ~isempty(trxids);
      tfview = ~isempty(view);
      tfcrop = ~isempty(croproi);
      
      aptintrf = [deepnetroot '/APT_interface.py'];
      
      assert(~(tftrx && tfcrop));
      if tfcrop 
        % APT_interface.py supports multiple views/crops but for now
        % restrict here
        assert(numel(croproi)==4);
        if tfview
          assert(numel(view)==1);
        end
      end
      
      codestr = sprintf('python %s -name %s',aptintrf,trnID);
      if tfview
        codestr = [codestr sprintf(' -view %d',view)]; % view: 1-based for APT_interface
      end
      if tfcache
        codestr = [codestr ' -cache ' cache];
      end
      codestr = [codestr ' -err_file ' errfile ' -type ' char(nettype)];
      if ~isempty(model_file),
        codestr = sprintf('%s -model_file %s',codestr,model_file);
      end
      codestr = [codestr sprintf(' %s track -mov %s -out %s',dllbl,movtrk,outtrk)];
      if ~isempty(frm0) && ~isempty(frm1),
        codestr = [codestr, sprintf(' -start_frame %d -end_frame %d',frm0,frm1)];
      end
      if tftrx
        codestr = sprintf('%s -trx %s',codestr,trxtrk);
        if tftrxids
          trxids = num2cell(trxids); % 1-based for APT_interface
          trxidstr = sprintf('%d ',trxids{:});
          trxidstr = trxidstr(1:end-1);
          codestr = sprintf('%s -trx_ids %s',codestr,trxidstr);
        end
      end
      if tfcrop
        roistr = mat2str(croproi);
        roistr = roistr(2:end-1);
        codestr = sprintf('%s -crop_loc %s',codestr,roistr);
      end
      if hmaps
        codestr = sprintf('%s -hmaps',codestr);
      end
    end
    
    function [codestr,containerName] = trackCodeGenDocker(...
        trnID,cache,dllbl,errfile,...
        nettype,movtrk,outtrk,frm0,frm1,varargin)
%         movtrk,outtrk,frm0,frm1,...
%         modelChainID,trainID,dllbl,cache,errfile,netType,view1b,mntPaths,...
%         varargin)

      % varargin: see trackCodeGenBase, except for 'cache' and 'view'
      
      [baseargs,dockerargs,mntPaths,containerName] = myparse(varargin,...
        'baseargs',{},'dockerargs',{},'mntPaths',{},'containerName','');
      
      baseargs = [{'cache' cache} baseargs];
        
      basecmd = DeepTracker.trackCodeGenBase(trnID,dllbl,errfile,nettype,...
        movtrk,outtrk,frm0,frm1,baseargs{:});

      if isempty(containerName),
        [~,containerName] = fileparts(outtrk);
      end

      codestr = DeepTracker.codeGenDockerGeneral(basecmd,containerName,...
        'bindpath',mntPaths,dockerargs{:});
    end
    function codestr = trackCodeGenVenv(trnID,dllbl,movtrk,outtrk,frm0,frm1,varargin)
      [baseargs,venvHost,venv,cudaVisDevice,logFile] = myparse(varargin,...
        'baseargs',{},... % p-v cell for trackCodeGenBase
        'venvHost','10.103.20.155',... % host to run DL verman-ws1
        'venv','/groups/branson/bransonlab/mayank/venv',... 
        'cudaVisDevice',[],... % if supplied, export CUDA_VISIBLE_DEVICES to this
        'logFile','/dev/null'...
      ); 
      
      basecode = DeepTracker.trackCodeGenBase(trnID,dllbl,movtrk,outtrk,...
        frm0,frm1,baseargs{:});
      if ~isempty(cudaVisDevice)
        cudaDeviceStr = ...
          sprintf('export CUDA_DEVICE_ORDER=PCI_BUS_ID; export CUDA_VISIBLE_DEVICES=%d; ',...
          cudaVisDevice);
      else
        cudaDeviceStr = '';
      end
        
      codestrremote = sprintf('cd %s; source bin/activate; %s%s',venv,...
        cudaDeviceStr,basecode);
      codestr = DeepTracker.codeGenSSHGeneral(codestrremote,...
        'host',venvHost,'logfile',logFile);
    end
    function codestr = trackCodeGenSing(trnID,dllbl,errfile,nettype,...
        movtrk,outtrk,frm0,frm1,varargin)
      [baseargs,singargs] = myparse(varargin,...
        'baseargs',{},...
        'singargs',{});
      basecmd = DeepTracker.trackCodeGenBase(trnID,dllbl,errfile,nettype,...
        movtrk,outtrk,frm0,frm1,baseargs{:});
      codestr = DeepTracker.codeGenSingGeneral(basecmd,singargs{:});
    end
    function codestr = trackCodeGenBsubSing(trnID,dllbl,errfile,nettype,...
        movtrk,outtrk,frm0,frm1,varargin)
      [baseargs,singargs,bsubargs] = myparse(varargin,...
        'baseargs',{},...
        'singargs',{},...
        'bsubargs',{});
      basecmd = DeepTracker.trackCodeGenSing(trnID,dllbl,errfile,nettype,...
        movtrk,outtrk,frm0,frm1,'baseargs',baseargs,'singargs',singargs);
      codestr = DeepTracker.codeGenBsubGeneral(basecmd,bsubargs{:});
    end
    
    function codestr = trackCodeGenSSHBsubSing(trnID,cache,dllbl,errfile,...
        nettype,movtrk,outtrk,frm0,frm1,varargin)
      [baseargs,singargs,bsubargs,sshargs] = myparse(varargin,...
        'baseargs',{},...
        'singargs',{},...
        'bsubargs',{},...
        'sshargs',{}...
        );
      baseargs = [baseargs {'cache' cache}];
      remotecmd = DeepTracker.trackCodeGenBsubSing(trnID,dllbl,errfile,...
        nettype,movtrk,outtrk,frm0,frm1,...
        'baseargs',baseargs,'singargs',singargs,'bsubargs',bsubargs);
      codestr = DeepTracker.codeGenSSHGeneral(remotecmd,sshargs{:});
    end
    function codestr = trackCodeGenAWS(...
        trnID,cacheRemote,dlLblRemote,errfileRemote,netType,movRemoteFull,...
        trkRemoteFull,frm0,frm1,baseargs)
      % baseargs: PV cell vector that goes to .trackCodeGenBase
      
      deepnetroot = '~/APT/deepnet';
      baseargs = [baseargs {'cache' cacheRemote}];
      codestrbase = DeepTracker.trackCodeGenBase(trnID,dlLblRemote,...
        errfileRemote,netType,movRemoteFull,trkRemoteFull,frm0,frm1,...
        'deepnetroot',deepnetroot,baseargs{:});
      
      codestr = {
         'cd /home/ubuntu/APT/deepnet;';
         'export LD_LIBRARY_PATH=/home/ubuntu/src/cntk/bindings/python/cntk/libs:/usr/local/cuda/lib64:/usr/local/lib:/usr/lib:/usr/local/cuda/extras/CUPTI/lib64:/usr/local/mpi/lib;';
         codestrbase
        };
      codestr = cat(2,codestr{:});
    end
    
    function [m,tfsuccess,isold] = parseTrkFileName(trkfile)
      
      tfsuccess = false;
      isold = false;
      [p,n,e] = fileparts(trkfile);
      m = regexp(n,'^(?<base>.*)_trn(?<trn_ts>.*)_iter(?<iter>.*)_(?<trk_ts>.*)$','names','once');
      if isempty(m),
        m = regexp(n,'^(?<base>.*)_trn(?<trn_ts>.*)_(?<trk_ts>.*)$','names','once');
        if ~isempty(m),
          fprintf('trkfile %s does not have iteration name in it. parsing trkInfo.model_file to determine...\n',trkfile);
          try
            tmp = load(trkfile,'trkInfo','-mat');
            iter = DeepModelChainOnDisk.getModelFileIter(char(tmp.trkInfo.model_file));
            m.iter = iter(1);
            isold = true;
          catch ME,
            warning('Could not parse iteration from trkInfo.model_file');
            getReport(ME);
            return;
          end
        else
          warning('Could not parse trkfile name %s',trkfile);
          return;
        end
      else
        m.iter = str2double(m.iter);
        isold = false;
      end
      m.path = p;
      m.ext = e;
      m.newName = fullfile(m.path,[m.base '_trn' m.trn_ts '_iter' num2str(m.iter) '_' m.trk_ts m.ext]);
      tfsuccess = true;
    end

  end
  methods (Static) % train/track broker util
    function hdir = dlerrGetHomeDir
      m = getenvall;
      hdir = m('HOME');
    end
%     function errfile = dlGetTrackErrFile(trnID,hdir)
%       if exist('hdir','var')==0
%         hdir = DeepTracker.dlerrGetHomeDir;
%       end
%       nowstr = datestr(now,'yyyymmddTHHMMSS');
%       errfileS = [trnID '_' nowstr '.err'];
%       errfile = fullfile(hdir,errfileS);
%     end
  end
  
  %% TrackRes = Tracking DB. all known tracking results on disk.  
  methods
    function trackResInit(obj)
      m = containers.Map('keytype','int32','valuetype','any');
      obj.movIdx2trkfile = m;
    end
    function trackResAddTrkfile(obj,mIdx,trkfiles)
      % Remember/add a set of [nview] trkfiles associated with mIdx
      
      assert(isscalar(mIdx));
      assert(iscellstr(trkfiles));
            
      [v,id] = obj.trackResGetTrkfiles(mIdx);      
      v(end+1,:) = trkfiles(:)';
      obj.movIdx2trkfile(id) = v;
    end
    function [trkfiles,id] = trackResGetTrkfiles(obj,mIdx)
      % trkfiles: [ntrkfilesxnview] fullpath trkfiles for given scalar
      % MovieIndex
      m = obj.movIdx2trkfile;
      id = mIdx.id32();
      if m.isKey(id)
        trkfiles = m(id);
      else
        trkfiles = cell(0,obj.lObj.nview);
      end      
    end
    function trackResSetTrkfiles(obj,mIdx,trkfiles)
      % trkfiles: [ntrkfilesxnview] fullpath trkfiles for given scalar
      % MovieIndex
      m = obj.movIdx2trkfile;
      id = mIdx.id32();
      if m.isKey(id)
        obj.movIdx2trkfile(id) = trkfiles;
      else
        obj.trackResAddTrkfile(mIdx,trkfiles)
      end      
    end
    function removeMissingTrkFiles(obj,mIdx)
      [trkfiles,id] = obj.trackResGetTrkfiles(mIdx);
      tfexists = cellfun(@(x) exist(x,'file'),trkfiles)>0;
      if ~all(tfexists),
        obj.movIdx2trkfile(id) = trkfiles(tfexists);
      end
    end
    function tpos = getTrackingResultsCurrMovie(obj)
      tpos = obj.trkP;
    end
    function [trkfileObjs,tfHasRes] = getTrackingResults(obj,mIdx)
      % Get tracking results for MovieIndices mIdx
      %
      % mIdx: [nMov] vector of MovieIndices
      %
      % trkfiles: [nMovxnView] cell of TrkFile objects, or [] if tfHasRes(...) is false
      % tfHasRes: [nMov] logical. If true, corresponding movie(set) has 
      %   tracking nontrivial (nonempty) tracking results
      %
      % DeepTracker uses the filesys as the tracking result DB. This loads 
      % from known/expected trkfiles.
            
      assert(isa(mIdx,'MovieIndex'));
      nMov = numel(mIdx);
      nView = obj.nview;
      trkfileObjs = cell(nMov,nView);
      tfHasRes = false(nMov,1);
      for i=1:nMov
        trkfilesI = obj.trackResGetTrkfiles(mIdx(i));
        ntrk = size(trkfilesI,1);
        
        if ntrk==0
          % trkfileObjs, tfHasRes, trkfiles initted appropriately
          continue;
        end          
        if ntrk>1
          warningNoTrace('Merging tracking results from %d poseTF trkfiles.\n',ntrk);
        end        
        for ivw=1:nView
          [trkfilesIobj,tfsuccload] = cellfun(@DeepTracker.hlpLoadTrk,...
            trkfilesI(:,ivw),'uni',0);
          tfsuccload = cell2mat(tfsuccload);
          trkfilesIobj = trkfilesIobj(tfsuccload);
          if isempty(trkfilesIobj)
            % if all loads failed
            % none; trkfiles, tfHasRes OK
          else
            tObj = trkfilesIobj{1};
            for iTmp=2:numel(trkfilesIobj)
              tObj.mergePartial(trkfilesIobj{iTmp});
            end
            trkfileObjs{i,ivw} = tObj;
            tfHasRes(i) = true;
          end
        end
      end
    end
    function isCurr = checkTrackingResultsCurrent(obj)
      
      isCurr = true;
      obj.updateLastDMCsCurrInfo();
      
      for moviei = 1:obj.lObj.nmovies,
        mIdx = MovieIndex(moviei);
        % some trkfiles don't exist for some reason
        obj.removeMissingTrkFiles(mIdx);
        [trkfiles] = obj.trackResGetTrkfiles(mIdx);
        if isempty(trkfiles),
          continue;
        end
        
        isFixed = false;
        newtrkfiles = trkfiles;
        for i = 1:size(trkfiles,1),
          for ivw = 1:size(trkfiles,2),
            [isCurr,tfSuccess,isOldFileName,trkInfo] = checkTrkFileCurrent(obj,trkfiles{i,ivw},ivw);
            assert(tfSuccess);
            if isOldFileName,
              isFixed = true;
              [tfSucc,msg] = copyfile(trkfiles{i,ivw},trkInfo.newName);
              if ~tfSucc,
                warning('Could not rename %s to %s: %s',trkfiles{i,ivw},newtrkfiles{i,ivw},msg);
              else
                newtrkfiles{i,ivw} = trkInfo.newName;
              end
            end
            if ~isCurr,
              %fprintf('Trkfile %s out of date, removing all tracking for movie %d\n',trkfiles{i},moviei);
              break;
            end
          end
        end
        if isFixed,
          obj.trackResSetTrkfiles(mIdx,newtrkfiles);
        end
        if ~isCurr,
          break;
        end

      end
      
    end
    
    function tblMFT = getTrackedMFT(obj,mIdxs)
      
      tblMFT = [];
      if nargin < 2,
        mIdxs = MovieIndex(1:obj.lObj.nmovies);
      end
      
      for mIdx = mIdxs(:)',
        [tblTrkRes] = obj.getAllTrackResTable(mIdx);
        if isempty(tblTrkRes),
          continue;
        end
        frm = tblTrkRes.frm;
        iTgt = tblTrkRes.iTgt;
        mov = repmat(mIdx,size(frm));
        tblMFT = [tblMFT;table(mov,frm,iTgt)]; %#ok<AGROW>

      end
      
    end
    
    function cleanOutOfDateTrackingResults(obj,isCurr)

      if nargin < 2,
        isCurr = obj.checkTrackingResultsCurrent();
      end
      if isCurr,
        return;
      end
      obj.trackResInit();
      obj.trackCurrResInit();

%       for i = 1:numel(trkFilesToDelete),
%         delete(trkFilesToDelete{i});
%         if exist(trkFilesToDelete{i},'file'),
%           warning('Failed to delete trk file %s',trkFilesToDelete{i});
%         end
%       end
      
      
    end
    
    function [isCurr,tfSuccess,isOldFileName,trkInfo] = checkTrkFileCurrent(obj,trkfile,ivw)
      isCurr = true;
      [trkInfo,tfSuccess,isOldFileName] = DeepTracker.parseTrkFileName(trkfile);
      if ~tfSuccess,
        return;
      end
      isCurr = strcmp(obj.trnLastDMC(ivw).modelChainID,trkInfo.trn_ts) && ...
        (obj.trnLastDMC(ivw).iterCurr==trkInfo.iter);
    end
    
    function tf = isTrkFiles(obj)
    
      tf = false;
      for i = 1:obj.lObj.nmovies,
        mIdx = MovieIndex(i);
        [trkfiles] = obj.trackResGetTrkfiles(mIdx);
        if ~isempty(trkfiles),
          tf = true;
          return;
        end
      end
      
    end
    
  end
  methods (Static)
    function [trkfileObj,tfsuccload] = hlpLoadTrk(tfile)
      try
        trkfileObj = TrkFile.loadsilent(tfile);
        tfsuccload = true;
      catch ME
        warningNoTrace('Failed to load trkfile: ''%s''. Error: %s',...
          tfile,ME.message);
        trkfileObj = [];
        tfsuccload  = false;
      end
    end
  end
  methods
    function [tblTrkRes,pTrkiPt] = getAllTrackResTable(obj,mIdxs) % obj const
      % Get all current tracking results in a table
      %
      % tblTrkRes: [NTrk x ncol] table of tracking results
      %            .pTrk, like obj.trkP; ABSOLUTE coords
      % pTrkiPt: [npttrk] indices into 1:obj.npts, tracked points. 
      %          size(tblTrkRes.pTrk,2)==npttrk*d

%       if obj.lObj.nview>1
%         error('Currently unsupported for multiview projects.');
%       end
      
      m = obj.movIdx2trkfile;
      
      if m.isempty
        tblTrkRes = [];
        pTrkiPt = [];
        return;
      end
      
      if nargin < 2,
        mIdxs = m.keys;
        mIdxs = cell2mat(mIdxs(:));
      end
      if ~isa(mIdxs,'MovieIndex'),
        mIdxs = MovieIndex(mIdxs);
      end
      [trk,tfhasres] = obj.getTrackingResults(mIdxs);

      tblTrkRes = [];
      pTrkiPt = -1;
      for i=1:numel(mIdxs)
        if tfhasres(i)
          if isequal(pTrkiPt,-1)
            pTrkiPt = trk{i,1}.pTrkiPt;
          end
          if ~isequal(pTrkiPt,trk{i,1}.pTrkiPt)
            error('Trkfiles differ in tracked points .pTrkiPt.');
          end
          tbl = trk{i,1}.tableform;
          tblTrkRes = [tblTrkRes;tbl]; %#ok<AGROW>
        end         
      end
    end
    function clearTrackingResults(obj)
      % FUTURE TODO: For now we do not actually delete the previous trkfiles.
      obj.trackResInit();
      obj.trackCurrResUpdate();
      obj.newLabelerFrame();
    end
  end
  
  %% TrackCurrRes = tracked state for current movie. Loaded into .trkP*
  methods
    function trackCurrResInit(obj)
      obj.trkP = [];
      obj.trkPTS = zeros(0,1);
    end
    function trackCurrResUpdate(obj)
      % update trackCurrRes (.trkP*) from trackRes (tracking DB)
      mIdx = obj.lObj.currMovIdx;
      if isempty(mIdx)
        % proj load etc
        return;
      end
      [trks,tfHasRes] = obj.getTrackingResults(mIdx);
      if tfHasRes
        obj.trackCurrResLoadFromTrks(trks);
        
        tfTrx = obj.lObj.hasTrx;
        
        trkfilesCurr = obj.trackResGetTrkfiles(mIdx); % [ntrk x nview]
        ntrkCurr = size(trkfilesCurr,1);
        for ivw=1:1 % TODO: multiview
          for itrk=1:ntrkCurr
            trkfile = trkfilesCurr{itrk,ivw};
            [trkfileP,trkfileF] = fileparts(trkfile);
            hmapDirS = [trkfileF '_hmap'];
            hmapDir = fullfile(trkfileP,hmapDirS);
            if exist(hmapDir,'dir')>0
              if tfTrx
                % Ideally the heatmaps size is related to 
                % sPrm....TargetCrop.Radius, but they might not have set
                % that, etc etc
                hmnr = [];
                hmnc = [];
              else
                hmnr = obj.lObj.movienr;
                hmnc = obj.lObj.movienc;
              end
              obj.trkVizer.heatMapInit(hmapDir,hmnr,hmnc);
              if ntrkCurr==1
                fprintf('Found heatmap dir: %s\n',hmapDirS);
              else                
                fprintf('Found heatmap dir %s for trkfile %d/%d. Other heatmap dirs (if any) will be ignored.\n',...
                  hmapDirS,itrk,ntrkCurr);
              end
              break;
            end
          end
        end
      else
        obj.trackCurrResInit();
      end
      notify(obj,'newTrackingResults');
    end
    function trackCurrResLoadFromTrks(obj,trks)
      % trks: [nview] cell of TrkFile objs
      
      assert(numel(trks)==obj.nview);
      
      lObj = obj.lObj;
      ipt2view = lObj.labeledposIPt2View;
      pTrk = nan(obj.nPts,2,lObj.nframes,lObj.nTargets);
      pTrkTS = nan(obj.nPts,lObj.nframes,lObj.nTargets);      
      for iview=1:obj.nview
        t = trks{iview};
        frms = t.pTrkFrm;
        itgts = t.pTrkiTgt;
        ipts = ipt2view==iview;
        pTrk(ipts,:,frms,itgts) = t.pTrk;
        pTrkTS(ipts,frms,itgts) = t.pTrkTS;
      end
      
      obj.trkP = pTrk;
      obj.trkPTS = pTrkTS;
    end
    function xy = getPredictionCurrentFrame(obj)
      % xy: [nPtsx2xnTgt], tracking results for all targets in current frm
      
      frm = obj.lObj.currFrame;
      xyPCM = obj.trkP;
      if isempty(xyPCM)
        npts = obj.nPts;
        nTgt = obj.lObj.nTargets;
        xy = nan(npts,2,nTgt);
      else
        % AL20160502: When changing movies, order of updates to 
        % lObj.currMovie and lObj.currFrame is unspecified. currMovie can
        % be updated first, resulting in an OOB currFrame; protect against
        % this.
        frm = min(frm,size(xyPCM,3));
        xy = squeeze(xyPCM(:,:,frm,:)); % [npt x d x ntgt]
      end
    end
  end
    
  %% Viz
  methods
    function vizInit(obj)
      obj.trkVizer.vizInit();
      obj.setHideViz(obj.hideViz);
    end
    function setHideViz(obj,tf)
      obj.trkVizer.setHideViz(tf);
      obj.hideViz = tf;
    end
    function updateLandmarkColors(obj)
      ptsClrs = obj.lObj.projPrefs.Track.PredictPointsPlotColors;      
      obj.trkVizer.updateLandmarkColors(ptsClrs);      
    end
  end

  %% Labeler nav
  methods
    function newLabelerFrame(obj)
      lObj = obj.lObj;
      if lObj.isinit || ~lObj.hasMovie
        return;
      end
            
      xy = obj.getPredictionCurrentFrame();    
      frm = lObj.currFrame;
      itgt = lObj.currTarget;
      trx = lObj.currTrx;
      if isempty(trx)
        trxXY = [];
        trxTh = [];        
      else
        itrx = frm+trx.off;
        if itrx <= 0 || itrx > numel(trx.x),
          return;
        end
        trxXY = [trx.x(itrx) trx.y(itrx)];
        trxTh = trx.theta(itrx);        
      end        
      obj.trkVizer.updateTrackRes(xy(:,:,itgt),frm,itgt,trxXY,trxTh);
    end
    function newLabelerTarget(obj)
      obj.newLabelerFrame();
    end
    function newLabelerMovie(obj)
      obj.vizInit(); % not sure why this is nec
      if obj.lObj.hasMovie
        obj.trackCurrResUpdate();
        obj.newLabelerFrame();
      end
    end
  end
  
  %% Labeler listeners
  methods
    function labelerMovieRemoved(obj,edata)
      mIdxOrig2New = edata.mIdxOrig2New;
      tfLabeledRowRemoved = ~isempty(edata.mIdxRmedHadLbls);
      if tfLabeledRowRemoved
        warningNoTrace('Labeled row(s) removed from project. Clearing trained tracker and tracking results.');
        obj.initHook();
      else
        % relabel movie indices
        obj.movIdx2trkfile = mapKeyRemap(obj.movIdx2trkfile,mIdxOrig2New);
        
        % this might not be nec b/c the preds for current movie might not
        % ever change
        obj.trackCurrResUpdate();
        obj.newLabelerFrame();
      end      
    end
    function labelerMoviesReordered(obj,edata)
      mIdxOrig2New = edata.mIdxOrig2New;
      obj.movIdx2trkfile = mapKeyRemap(obj.movIdx2trkfile,mIdxOrig2New);
      
      % Assume trackCurrRes does not need update
    end
  end  
  
end